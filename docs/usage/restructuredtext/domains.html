
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>域 &#8212; Sphinx 2.1.0+/ec574630c 文档</title>
    <link rel="stylesheet" href="../../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Sphinx 2.1.0+/ec574630c 文档 中搜索"
          href="../../_static/opensearch.xml"/>

    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Markdown" href="../markdown.html" />
    <link rel="prev" title="域清单" href="field-lists.html" />
<link rel="canonical" href="http://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html" />

<link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css' />
 
<style type="text/css">
  table.right {
    float: right;
    margin-left: 20px;
  }

  table.right td {
    border: 1px solid #ccc;
  }

    {
    % if pagename=='index'%
  }

  .related {
    display: none;
  }

    {
    % endif %
  }
</style>
<script type="text/javascript">
  // intelligent scrolling of the sidebar content
  $(window).scroll(function () {
    var sb = $('.sphinxsidebarwrapper');
    var win = $(window);
    var sbh = sb.height();
    var offset = $('.sphinxsidebar').position()['top'];
    var wintop = win.scrollTop();
    var winbot = wintop + win.innerHeight();
    var curtop = sb.position()['top'];
    var curbot = curtop + sbh;
    // does sidebar fit in window?
    if (sbh < win.innerHeight()) {
      // yes: easy case -- always keep at the top
      sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
        $(document).height() - sbh - 200
      ]));
    } else {
      // no: only scroll if top/bottom edge of sidebar is at
      // top/bottom edge of window
      if (curtop > wintop && curbot > winbot) {
        sb.css('top', $u.max([wintop - offset - 10, 0]));
      } else if (curtop < wintop && curbot < winbot) {
        sb.css('top', $u.min([winbot - sbh - offset - 20,
          $(document).height() - sbh - 200
        ]));
      }
    }
  });
</script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../../index.html">主页</a></li>
    <li><a href="../installation.html">安装</a></li>
    <li><a href="../../contents.html">文档</a></li>
    <li><a href="../../develop.html">扩展/开发</a></li>
  </ul>
  <div>
    <a href="../../index.html">
      <img src="../../_static/sphinxheader.png" alt="SPHINX" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="../markdown.html" title="Markdown"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="field-lists.html" title="域清单"
             accesskey="P">上一页</a> |</li>
<li><a href="../../index.html">主页</a>&#160;|</li>
<li><a href="../../contents.html">文档</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">reStructuredText</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">域</a><ul>
<li><a class="reference internal" href="#basic-markup">基本标记</a><ul>
<li><a class="reference internal" href="#cross-referencing-syntax">交叉引用语法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-python-domain">Python域</a><ul>
<li><a class="reference internal" href="#python-signatures">Python签名</a></li>
<li><a class="reference internal" href="#info-field-lists">信息字段列表</a></li>
<li><a class="reference internal" href="#cross-referencing-python-objects">交叉引用Python对象</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-c-domain">C域</a><ul>
<li><a class="reference internal" href="#cross-referencing-c-constructs">交叉引用C构造</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpp-domain">C++ 域</a><ul>
<li><a class="reference internal" href="#directives-for-declaring-entities">声明实体的指令</a><ul>
<li><a class="reference internal" href="#options">选项</a></li>
</ul>
</li>
<li><a class="reference internal" href="#anonymous-entities">匿名实体</a></li>
<li><a class="reference internal" href="#aliasing-declarations">别名声明</a></li>
<li><a class="reference internal" href="#constrained-templates">约束模板</a><ul>
<li><a class="reference internal" href="#placeholders">占位符</a></li>
<li><a class="reference internal" href="#template-introductions">模板介绍</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inline-expressions-and-types">内联表达式和类型</a></li>
<li><a class="reference internal" href="#namespacing">命名空间</a></li>
<li><a class="reference internal" href="#id3">信息字段列表</a></li>
<li><a class="reference internal" href="#cross-referencing">交叉引用</a><ul>
<li><a class="reference internal" href="#declarations-without-template-parameters-and-template-arguments">没有模板参数和模板参数的声明</a></li>
<li><a class="reference internal" href="#overloaded-member-functions">重载(成员)函数</a></li>
<li><a class="reference internal" href="#templated-declarations">模板化的声明</a></li>
<li><a class="reference internal" href="#full-template-specialisations">(完整)模板专业化</a></li>
<li><a class="reference internal" href="#partial-template-specialisations">部分模板专业化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration-variables">配置变量</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-standard-domain">标准域</a></li>
<li><a class="reference internal" href="#the-javascript-domain">JavaScript域</a></li>
<li><a class="reference internal" href="#the-restructuredtext-domain">reStructuredText域</a></li>
<li><a class="reference internal" href="#the-math-domain">数学域</a></li>
<li><a class="reference internal" href="#more-domains">更多域</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="field-lists.html"
                        title="上一章">域清单</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="../markdown.html"
                        title="下一章">Markdown</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/usage/restructuredtext/domains.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="domains">
<h1>域<a class="headerlink" href="#domains" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
<p>最初，Sphinx是为单个项目构思的，即Python语言的文档。不久之后，它作为一个文档工具提供给每个人，但Python模块的文档仍然内置 - 最基本的指令，如 <code class="docutils literal notranslate"><span class="pre">function</span></code> ，是为Python对象设计的。由于Sphinx已经变得有些受欢迎，因此将其用于许多不同目的的兴趣: C/C++ 项目，JavaScript，甚至是reStructuredText标记(如本文档中所述)。</p>
<p>虽然这总是可行的，但现在通过为每个此类目的提供 <strong>domain</strong> ，可以更轻松地轻松支持使用不同编程语言的项目文档，甚至是主要Sphinx发行版不支持的项目文档。</p>
<p>域是一组标签(reStructuredText <a class="reference internal" href="../../glossary.html#term-directive"><span class="xref std std-term">directive</span></a>s and <a class="reference internal" href="../../glossary.html#term-role"><span class="xref std std-term">role</span></a>s)，用于描述和链接 <a class="reference internal" href="../../glossary.html#term-object"><span class="xref std std-term">object</span></a>s ，属于一起，例如编程语言的元素。域中的指令和角色名称具有诸如 <code class="docutils literal notranslate"><span class="pre">domain:name</span></code> 之类的名称，例如 <code class="docutils literal notranslate"><span class="pre">py:function</span></code> 。域还可以提供自定义索引(例如Python模块索引)。</p>
<p>拥有域意味着当一组文档想要引用时，没有命名问题。 C++ 和 Python 类。这也意味着支持全新语言文档的扩展更容易编写。</p>
<p>本节介绍Sphinx提供的域名。域API也在以下部分中记录 <a class="reference internal" href="../../extdev/domainapi.html#domain-api"><span class="std std-ref">Domain API</span></a> 。</p>
<div class="section" id="basic-markup">
<span id="basic-domain-markup"></span><h2>基本标记<a class="headerlink" href="#basic-markup" title="永久链接至标题">¶</a></h2>
<p>大多数域提供了许多 <em class="dfn">object description directives</em> ，用于描述模块提供的特定对象。每个指令都需要一个或多个签名来提供有关所描述内容的基本信息，内容应该是描述。基本版本在一般索引中生成条目;如果不需要索引条目，可以给出指令选项标志 <code class="docutils literal notranslate"><span class="pre">:noindex:</span></code> 。使用Python域指令的示例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:function</span><span class="p">::</span> spam(eggs)
                 ham(eggs)

   Spam or ham the foo.
</pre></div>
</div>
<p>这描述了两个Python函数 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ham</span></code> 。 (请注意，当签名变得太长时，如果向下一行中继续的行添加反斜杠，则可以将其分解。示例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:function</span><span class="p">::</span> filterwarnings(action, message=&#39;&#39;, category=Warning, \
                                module=&#39;&#39;, lineno=0, append=False)
   <span class="nc">:noindex:</span>
</pre></div>
</div>
<p>(这个例子还展示了如何使用 <code class="docutils literal notranslate"><span class="pre">:noindex:</span></code> 标志。)</p>
<p>域还提供链接回这些对象描述的角色。例如，要链接到上面示例中描述的其中一个函数，您可以说:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>The function <span class="na">:py:func:</span><span class="nv">`spam`</span> does a similar thing.
</pre></div>
</div>
<p>如您所见，指令和角色名称都包含域名和指令名称。</p>
<p class="rubric">默认域</p>
<p>对于仅从一个域描述对象的文档，作者在指定默认值后，不必再在每个指令，角色等处再次声明其名称。这可以通过配置值 <a class="reference internal" href="../configuration.html#confval-primary_domain"><code class="xref std std-confval docutils literal notranslate"><span class="pre">primary_domain</span></code></a> 或通过此指令来完成:</p>
<dl class="directive">
<dt id="directive-default-domain">
<code class="descname">.. default-domain::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-default-domain" title="永久链接至目标">¶</a></dt>
<dd><p>选择一个新的默认域。虽然 <a class="reference internal" href="../configuration.html#confval-primary_domain"><code class="xref std std-confval docutils literal notranslate"><span class="pre">primary_domain</span></code></a> 选择全局默认值，但这只在同一个文件中有效。</p>
</dd></dl>

<p>如果没有选择其他默认值，则Python域(名为 <code class="docutils literal notranslate"><span class="pre">py</span></code> )是默认值，主要是为了与为旧版Sphinx编写的文档兼容。</p>
<p>可以在不提供域名的情况下提及属于默认域的指令和角色，即:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">function</span><span class="p">::</span> pyfunc()

   Describes a Python function.

Reference to <span class="na">:func:</span><span class="nv">`pyfunc`</span>.
</pre></div>
</div>
<div class="section" id="cross-referencing-syntax">
<h3>交叉引用语法<a class="headerlink" href="#cross-referencing-syntax" title="永久链接至标题">¶</a></h3>
<p>对于域提供的交叉引用角色，存在与一般交叉引用相同的工具。请参阅 <a class="reference internal" href="roles.html#xref-syntax"><span class="std std-ref">交叉引用语法</span></a> 。</p>
<p>简而言之:</p>
<ul class="simple">
<li><p>你可以提供一个明确的标题和引用目标: <code class="docutils literal notranslate"><span class="pre">:role:`title</span> <span class="pre">&lt;target&gt;`</span></code> 将引用 <em>target</em> ，但链接文本将是 <em>title</em> 。</p></li>
<li><p>如果在内容前加上 <code class="docutils literal notranslate"><span class="pre">！</span></code> ，则不会创建引用/超链接。</p></li>
<li><p>如果在内容前面添加 <code class="docutils literal notranslate"><span class="pre">~</span></code> ，则链接文本将只是目标的最后一个组件。例如， <code class="docutils literal notranslate"><span class="pre">:py:meth:`~Queue.Queue.get`</span></code> 将引用 <code class="docutils literal notranslate"><span class="pre">Queue.Queue.get</span></code> 但仅显示 <code class="docutils literal notranslate"><span class="pre">get</span></code> 作为链接文本。</p></li>
</ul>
</div>
</div>
<div class="section" id="the-python-domain">
<h2>Python域<a class="headerlink" href="#the-python-domain" title="永久链接至标题">¶</a></h2>
<p>Python域(名称 <strong>py</strong> )为模块声明提供以下指令:</p>
<dl class="directive">
<dt id="directive-py:module">
<code class="descname">.. py:module::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:module" title="永久链接至目标">¶</a></dt>
<dd><p>该指令标志着模块(或包子模块)描述的开始，在这种情况下，名称应该是完全限定的，包括包名称。它不会创建内容(例如 <a class="reference internal" href="#directive-py:class" title="py:class directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:class</span></code></a> 确实如此)。</p>
<p>该指令还将导致全局模块索引中的条目。</p>
<p><code class="docutils literal notranslate"><span class="pre">platform</span></code> 选项(如果存在)是一个逗号分隔的模块可用平台列表(如果它在所有平台上都可用，则应省略该选项)。密钥是短标识符;正在使用的示例包括 “IRIX” ，”Mac” ， “Windows” 和 “Unix” 。使用已适用的密钥非常重要。</p>
<p>“概要”选项应包含一个描述模块用途的句子 - 它目前仅用于全局模块索引。</p>
<p>可以给出 <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> 选项(没有值)将模块标记为已弃用;它将在各个地点被指定。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:currentmodule">
<code class="descname">.. py:currentmodule::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:currentmodule" title="永久链接至目标">¶</a></dt>
<dd><p>该指令告诉Sphinx，这里记录的类，函数等都在给定的模块中(如 <a class="reference internal" href="#directive-py:module" title="py:module directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:module</span></code></a>)，但它不会创建索引条目，全局模块索引中的条目，或者一个链接目标 <a class="reference internal" href="#role-py:mod" title="py:mod role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">py:mod</span></code></a> 。这在模块中的事物文档分布在多个文件或部分的情况下很有用 - 一个位置具有 <a class="reference internal" href="#directive-py:module" title="py:module directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:module</span></code></a> 指令，其他只有 <a class="reference internal" href="#directive-py:currentmodule" title="py:currentmodule directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:currentmodule</span></code></a> 。</p>
</dd></dl>

<p>为模块和类内容提供以下指令:</p>
<dl class="directive">
<dt id="directive-py:function">
<code class="descname">.. py:function::</code><code class="descclassname"> name(parameters)</code><a class="headerlink" href="#directive-py:function" title="永久链接至目标">¶</a></dt>
<dd><p>描述模块级功能。签名应该包含Python函数定义中给出的参数，请参阅 <a class="reference internal" href="#signatures"><span class="std std-ref">Python签名</span></a> 。例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:function</span><span class="p">::</span> Timer.repeat(repeat=3, number=1000000)
</pre></div>
</div>
<p>对于你应该使用的方法 <a class="reference internal" href="#directive-py:method" title="py:method directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:method</span></code></a> 。</p>
<p>描述通常包括有关所需参数及其使用方式的信息(特别是是否修改了作为参数传递的可变对象)，副作用和可能的异常。</p>
<p>这个信息可以(在任何 <code class="docutils literal notranslate"><span class="pre">py</span></code> 指令中)可选地以结构化形式给出，参见 <a class="reference internal" href="#info-field-lists"><span class="std std-ref">信息字段列表</span></a> 。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:data">
<code class="descname">.. py:data::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:data" title="永久链接至目标">¶</a></dt>
<dd><p>描述模块中的全局数据，包括用作“定义的常量”的变量和值。使用此环境不记录类和对象属性。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:exception">
<code class="descname">.. py:exception::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:exception" title="永久链接至目标">¶</a></dt>
<dd><p>描述异常类。签名可以，但不必包括带有构造函数参数的括号。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:class">
<code class="descname">.. py:class::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:class" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">.. py:class::</code><code class="descclassname"> name(parameters)</code></dt>
<dd><p>描述一个类。签名可以选择包括带有参数的括号，这些参数将显示为构造函数参数。另见 <a class="reference internal" href="#signatures"><span class="std std-ref">Python签名</span></a> 。</p>
<p>属于该类的方法和属性应放在此指令的主体中。如果将它们放在外面，则提供的名称应包含类名，以便交叉引用仍然有效。例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:class</span><span class="p">::</span> Foo

<span class="p">   ..</span> <span class="ow">py:method</span><span class="p">::</span> quux()

-- or --

<span class="p">..</span> <span class="ow">py:class</span><span class="p">::</span> Bar

<span class="p">..</span> <span class="ow">py:method</span><span class="p">::</span> Bar.quux()
</pre></div>
</div>
<p>第一种方式是首选方式。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:attribute">
<code class="descname">.. py:attribute::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:attribute" title="永久链接至目标">¶</a></dt>
<dd><p>描述对象数据属性。描述应包括有关预期数据类型的信息以及是否可以直接更改。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:method">
<code class="descname">.. py:method::</code><code class="descclassname"> name(parameters)</code><a class="headerlink" href="#directive-py:method" title="永久链接至目标">¶</a></dt>
<dd><p>描述对象方法。参数不应包含 <code class="docutils literal notranslate"><span class="pre">self</span></code> 参数。描述应该包括与 <code class="docutils literal notranslate"><span class="pre">function</span></code> 描述的类似的信息。另见 <a class="reference internal" href="#signatures"><span class="std std-ref">Python签名</span></a> 和 <a class="reference internal" href="#info-field-lists"><span class="std std-ref">信息字段列表</span></a> 。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:staticmethod">
<code class="descname">.. py:staticmethod::</code><code class="descclassname"> name(parameters)</code><a class="headerlink" href="#directive-py:staticmethod" title="永久链接至目标">¶</a></dt>
<dd><p>像 <a class="reference internal" href="#directive-py:method" title="py:method directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:method</span></code></a> ，但表示该方法是静态方法。</p>
<div class="versionadded">
<p><span class="versionmodified added">0.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-py:classmethod">
<code class="descname">.. py:classmethod::</code><code class="descclassname"> name(parameters)</code><a class="headerlink" href="#directive-py:classmethod" title="永久链接至目标">¶</a></dt>
<dd><p>像 <a class="reference internal" href="#directive-py:method" title="py:method directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:method</span></code></a> ，但表示该方法是一个类方法。</p>
<div class="versionadded">
<p><span class="versionmodified added">0.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-py:decorator">
<code class="descname">.. py:decorator::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:decorator" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">.. py:decorator::</code><code class="descclassname"> name(parameters)</code></dt>
<dd><p>描述装饰器功能。签名应表示作为装饰者的用法。例如，给定功能</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">removename</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="k">def</span> <span class="nf">setnewname</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>
</div>
<p>描述应如下所示:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:decorator</span><span class="p">::</span> removename

   Remove name of the decorated function.

<span class="p">..</span> <span class="ow">py:decorator</span><span class="p">::</span> setnewname(name)

   Set name of the decorated function to <span class="ge">*name*</span>.
</pre></div>
</div>
<p>(而不是 <code class="docutils literal notranslate"><span class="pre">..</span> <span class="pre">py:decorator</span> <span class="pre">::</span> <span class="pre">removename(func)</span></code> 。)</p>
<p>没有 <code class="docutils literal notranslate"><span class="pre">py:deco</span></code> 角色链接到用这个指令标记的装饰器;相反，使用 <a class="reference internal" href="#role-py:func" title="py:func role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">py:func</span></code></a> 角色。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-py:decoratormethod">
<code class="descname">.. py:decoratormethod::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-py:decoratormethod" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">.. py:decoratormethod::</code><code class="descclassname"> name(signature)</code></dt>
<dd><p>与 <a class="reference internal" href="#directive-py:decorator" title="py:decorator directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:decorator</span></code></a> 相同，但对于作为方法的装饰器。</p>
<p>使用 <a class="reference internal" href="#role-py:meth" title="py:meth role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">py:meth</span></code></a> 角色引用装饰器方法。</p>
</dd></dl>

<div class="section" id="python-signatures">
<span id="signatures"></span><h3>Python签名<a class="headerlink" href="#python-signatures" title="永久链接至标题">¶</a></h3>
<p>函数，方法和类构造函数的签名可以像在Python中编写一样给出。</p>
<p>可以给出可选参数的默认值(但如果它们包含逗号，则会混淆签名解析器)。还可以给出Python 3样式的参数注释以及返回类型注释:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:function</span><span class="p">::</span> compile(source : string, filename, symbol=&#39;file&#39;) -&gt; ast object
</pre></div>
</div>
<p>对于具有可选参数但没有默认值的函数(通常在没有关键字参数支持的C扩展模块中实现的函数)，可以使用括号指定可选部分:</p>
<blockquote>
<div><dl class="function">
<dt id="compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>filename</em><span class="optional">[</span>, <em>symbol</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#compile" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</div></blockquote>
<p>习惯上将开口括号放在逗号之前。</p>
</div>
<div class="section" id="info-field-lists">
<span id="id1"></span><h3>信息字段列表<a class="headerlink" href="#info-field-lists" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">0.4 新版功能.</span></p>
</div>
<p>在Python对象描述指令中，具有这些字段的reST字段列表可以很好地识别和格式化:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code>, <code class="docutils literal notranslate"><span class="pre">parameter</span></code>, <code class="docutils literal notranslate"><span class="pre">arg</span></code>, <code class="docutils literal notranslate"><span class="pre">argument</span></code>, <code class="docutils literal notranslate"><span class="pre">key</span></code>, <code class="docutils literal notranslate"><span class="pre">keyword</span></code>:
Description of a parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>:参数的类型。如果可能，创建一个链接。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">raises</span></code>，<code class="docutils literal notranslate"><span class="pre">raise</span></code>，<code class="docutils literal notranslate"><span class="pre">except</span></code>，<code class="docutils literal notranslate"><span class="pre">exception</span></code>:那个(和什么时候)引发了一个特定的异常。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">ivar</span></code>, <code class="docutils literal notranslate"><span class="pre">cvar</span></code>: 变量的描述。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vartype</span></code>: Type of a variable.  如果可能，创建一个链接。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span></code>, <code class="docutils literal notranslate"><span class="pre">return</span></code>: 返回值的描述。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtype</span></code>: Return type.  如果可能，创建一个链接。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>在当前版本中，所有 <code class="docutils literal notranslate"><span class="pre">var</span></code> ， <code class="docutils literal notranslate"><span class="pre">ivar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cvar</span></code> 都表示为 “Variable” 。完全没有区别。</p>
</div>
<p>字段名称必须包含这些关键字之一和参数(除了 <code class="docutils literal notranslate"><span class="pre">returns</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rtype</span></code> ，它们不需要参数)。这可以用一个例子来解释:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">py:function</span><span class="p">::</span> send_message(sender, recipient, message_body, [priority=1])

   Send a message to a recipient

   <span class="nc">:param str sender:</span> <span class="nf">The person sending the message</span>
   <span class="nc">:param str recipient:</span> <span class="nf">The recipient of the message</span>
   <span class="nc">:param str message_body:</span> <span class="nf">The body of the message</span>
   <span class="nc">:param priority:</span> <span class="nf">The priority of the message, can be a number 1-5</span>
   <span class="nc">:type priority:</span> <span class="nf">integer or None</span>
   <span class="nc">:return:</span> <span class="nf">the message id</span>
   <span class="nc">:rtype:</span> <span class="nf">int</span>
   <span class="nc">:raises ValueError:</span> <span class="nf">if the message_body exceeds 160 characters</span>
   <span class="nc">:raises TypeError:</span> <span class="nf">if the message_body is not a basestring</span>
</pre></div>
</div>
<p>这将呈现如下:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">send_message</code><span class="sig-paren">(</span><em>sender</em>, <em>recipient</em>, <em>message_body</em><span class="optional">[</span>, <em>priority=1</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>向收件人发送邮件</p>
<dl class="field-list simple">
<dt class="field-odd">参数</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<em>str</em>) – 发送消息的人</p></li>
<li><p><strong>recipient</strong> (<em>str</em>) – 邮件的收件人</p></li>
<li><p><strong>message_body</strong> (<em>str</em>) – 消息的正文</p></li>
<li><p><strong>priority</strong> (<em>integer</em><em> or </em><em>None</em>) – 消息的优先级可以是1-5</p></li>
</ul>
</dd>
<dt class="field-even">返回</dt>
<dd class="field-even"><p>消息ID</p>
</dd>
<dt class="field-odd">返回类型</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">引发</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – 如果message_body超过160个字符</p></li>
<li><p><strong>TypeError</strong> – 如果message_body不是基本字符串</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div></blockquote>
<p>如果类型是单个单词，也可以组合参数类型和描述，如下:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="nc">:param int priority:</span> <span class="nf">The priority of the message, can be a number 1-5</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">1.5 新版功能.</span></p>
</div>
<p>可以使用以下语法自动链接容器类型(如列表和词典):</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="nc">:type priorities:</span> <span class="nf">list(int)</span>
<span class="nc">:type priorities:</span> <span class="nf">list[int]</span>
<span class="nc">:type mapping:</span> <span class="nf">dict(str, int)</span>
<span class="nc">:type mapping:</span> <span class="nf">dict[str, int]</span>
<span class="nc">:type point:</span> <span class="nf">tuple(float, float)</span>
<span class="nc">:type point:</span> <span class="nf">tuple[float, float]</span>
</pre></div>
</div>
<p>如果用单词“”或“”分隔，则类型字段中的多个类型将自动链接:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="nc">:type an_arg:</span> <span class="nf">int or None</span>
<span class="nc">:vartype a_var:</span> <span class="nf">str or int</span>
<span class="nc">:rtype:</span> <span class="nf">float or str</span>
</pre></div>
</div>
</div>
<div class="section" id="cross-referencing-python-objects">
<span id="python-roles"></span><h3>交叉引用Python对象<a class="headerlink" href="#cross-referencing-python-objects" title="永久链接至标题">¶</a></h3>
<p>以下角色引用模块中的对象，如果找到匹配的标识符，则可能是超链接:</p>
<dl class="role">
<dt id="role-py:mod">
<code class="descname">:py:mod:</code><a class="headerlink" href="#role-py:mod" title="永久链接至目标">¶</a></dt>
<dd><p>参考模块;可以使用虚线名称。这也应该用于包名称。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:func">
<code class="descname">:py:func:</code><a class="headerlink" href="#role-py:func" title="永久链接至目标">¶</a></dt>
<dd><p>引用Python函数;可以使用点名。角色文本不需要包括尾随括号以增强可读性;如果 <a class="reference internal" href="../configuration.html#confval-add_function_parentheses"><code class="xref std std-confval docutils literal notranslate"><span class="pre">add_function_parentheses</span></code></a> 配置值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (默认值)，它们将由Sphinx自动添加。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:data">
<code class="descname">:py:data:</code><a class="headerlink" href="#role-py:data" title="永久链接至目标">¶</a></dt>
<dd><p>引用模块级变量。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:const">
<code class="descname">:py:const:</code><a class="headerlink" href="#role-py:const" title="永久链接至目标">¶</a></dt>
<dd><p>引用一个“定义的”常量。这可能是一个不打算更改的Python变量。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:class">
<code class="descname">:py:class:</code><a class="headerlink" href="#role-py:class" title="永久链接至目标">¶</a></dt>
<dd><p>引用一个类;可以使用虚线名称。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:meth">
<code class="descname">:py:meth:</code><a class="headerlink" href="#role-py:meth" title="永久链接至目标">¶</a></dt>
<dd><p>引用对象的方法。角色文本可以包括类型名称和方法名称;如果它出现在类型的描述中，则可以省略类型名称。可以使用点状名称。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:attr">
<code class="descname">:py:attr:</code><a class="headerlink" href="#role-py:attr" title="永久链接至目标">¶</a></dt>
<dd><p>引用对象的数据属性。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:exc">
<code class="descname">:py:exc:</code><a class="headerlink" href="#role-py:exc" title="永久链接至目标">¶</a></dt>
<dd><p>引用异常。可以使用点状名称。</p>
</dd></dl>

<dl class="role">
<dt id="role-py:obj">
<code class="descname">:py:obj:</code><a class="headerlink" href="#role-py:obj" title="永久链接至目标">¶</a></dt>
<dd><p>引用未指定类型的对象。例如有用as <a class="reference internal" href="../configuration.html#confval-default_role"><code class="xref std std-confval docutils literal notranslate"><span class="pre">default_role</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">0.4 新版功能.</span></p>
</div>
</dd></dl>

<p>此标记中包含的名称可以包括模块名称和/或类名称。例如，<code class="docutils literal notranslate"><span class="pre">:py:func:`filter`</span></code> 可以引用当前模块中名为 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 的函数，或者该名称的内置函数。相比之下， <code class="docutils literal notranslate"><span class="pre">:py:func:`foo.filter`</span></code> 清楚地引用了 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 模块中的 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 函数。</p>
<p>通常，首先搜索这些角色中的名称而不进一步限定，然后将当前模块名称添加到前面，然后使用当前模块和类名(如果有)作为前缀。如果您在名称前加一个点，则此顺序相反。例如，在Python的文档 <code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> 模块中，<code class="docutils literal notranslate"><span class="pre">:py:func:`open`</span></code> 总是引用内置函数，而 <code class="docutils literal notranslate"><span class="pre">:py:func:`.open`</span></code> 指 <code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.open()</span></code> 。</p>
<p>类似的启发式方法用于确定名称是否是当前记录的类的属性。</p>
<p>此外，如果名称以点为前缀，并且未找到完全匹配，则将目标作为后缀，并搜索具有该后缀的所有对象名称。例如，<code class="docutils literal notranslate"><span class="pre">:py:meth:`.TarFile.close`</span></code> 引用 <code class="docutils literal notranslate"><span class="pre">tarfile.TarFile.close()</span></code> 函数，即使当前模块不是 <code class="docutils literal notranslate"><span class="pre">tarfile</span></code> 。由于这可能会变得模棱两可，如果有多个可能匹配，您将收到Sphinx的警告。</p>
<p>请注意，您可以组合使用 <code class="docutils literal notranslate"><span class="pre">~</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.</span></code> 前缀: <code class="docutils literal notranslate"><span class="pre">:py:meth:`~.TarFile.close`</span></code> 将引用 <code class="docutils literal notranslate"><span class="pre">tarfile.TarFile.close()</span></code> 方法，但可见的链接标题只是 <code class="docutils literal notranslate"><span class="pre">close()</span></code>。</p>
</div>
</div>
<div class="section" id="the-c-domain">
<span id="c-domain"></span><h2>C域<a class="headerlink" href="#the-c-domain" title="永久链接至标题">¶</a></h2>
<p>C域(名称 <strong>c</strong>)适用于C API的文档。</p>
<dl class="directive">
<dt id="directive-c:function">
<code class="descname">.. c:function::</code><code class="descclassname"> function prototype</code><a class="headerlink" href="#directive-c:function" title="永久链接至目标">¶</a></dt>
<dd><p>描述C函数。签名应如C所示，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">c:function</span><span class="p">::</span> PyObject<span class="ge">* PyType_GenericAlloc(PyTypeObject *</span>type, Py_ssize_t nitems)
</pre></div>
</div>
<p>这也用于描述类似函数的预处理器宏。应该给出参数的名称，以便它们可以在描述中使用。</p>
<p>请注意，签名中不必使用反斜杠转义星号，因为reST内联器不会对其进行解析。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-c:member">
<code class="descname">.. c:member::</code><code class="descclassname"> declaration</code><a class="headerlink" href="#directive-c:member" title="永久链接至目标">¶</a></dt>
<dd><p>描述C结构成员。签名示例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">c:member</span><span class="p">::</span> PyObject* PyTypeObject.tp_bases
</pre></div>
</div>
<p>描述文本应包括允许的值范围，应如何解释值以及是否可以更改值。对文本中结构成员的引用应使用 <code class="docutils literal notranslate"><span class="pre">member</span></code> 角色。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-c:macro">
<code class="descname">.. c:macro::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-c:macro" title="永久链接至目标">¶</a></dt>
<dd><p>描述一个 “simple” 的C宏。简单宏是用于代码扩展的宏，但不带参数，因此不能将其描述为函数。这是一个简单的C语言 <code class="docutils literal notranslate"><span class="pre">#define</span></code> 。它在Python文档中的使用示例包括 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code> 和 <code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code> 。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-c:type">
<code class="descname">.. c:type::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-c:type" title="永久链接至目标">¶</a></dt>
<dd><p>描述C类型(无论是由 typedef 还是 struct 定义)。签名应该只是类型名称。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-c:var">
<code class="descname">.. c:var::</code><code class="descclassname"> declaration</code><a class="headerlink" href="#directive-c:var" title="永久链接至目标">¶</a></dt>
<dd><p>描述全局C变量。签名应包括类型，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">c:var</span><span class="p">::</span> PyObject* PyClass_Type
</pre></div>
</div>
</dd></dl>

<div class="section" id="cross-referencing-c-constructs">
<span id="c-roles"></span><h3>交叉引用C构造<a class="headerlink" href="#cross-referencing-c-constructs" title="永久链接至标题">¶</a></h3>
<p>如果在文档中定义了以下角色，则会创建对C语言构造的交叉引用:</p>
<dl class="role">
<dt id="role-c:func">
<code class="descname">:c:func:</code><a class="headerlink" href="#role-c:func" title="永久链接至目标">¶</a></dt>
<dd><p>引用C语言函数。应该包括尾随括号。</p>
</dd></dl>

<dl class="role">
<dt id="role-c:member">
<code class="descname">:c:member:</code><a class="headerlink" href="#role-c:member" title="永久链接至目标">¶</a></dt>
<dd><p>引用结构的C语言成员。</p>
</dd></dl>

<dl class="role">
<dt id="role-c:macro">
<code class="descname">:c:macro:</code><a class="headerlink" href="#role-c:macro" title="永久链接至目标">¶</a></dt>
<dd><p>引用一个 “simple”  的C宏，如上所述。</p>
</dd></dl>

<dl class="role">
<dt id="role-c:type">
<code class="descname">:c:type:</code><a class="headerlink" href="#role-c:type" title="永久链接至目标">¶</a></dt>
<dd><p>引用C语言类型。</p>
</dd></dl>

<dl class="role">
<dt id="role-c:data">
<code class="descname">:c:data:</code><a class="headerlink" href="#role-c:data" title="永久链接至目标">¶</a></dt>
<dd><p>引用C语言变量。</p>
</dd></dl>

</div>
</div>
<div class="section" id="cpp-domain">
<span id="id2"></span><h2>C++ 域<a class="headerlink" href="#cpp-domain" title="永久链接至标题">¶</a></h2>
<p>C++ 域(名称 <strong>cpp</strong>)支持记录C++ 项目。</p>
<div class="section" id="directives-for-declaring-entities">
<h3>声明实体的指令<a class="headerlink" href="#directives-for-declaring-entities" title="永久链接至标题">¶</a></h3>
<p>以下指令可用。所有声明都可以从可见性声明开始(<code class="docutils literal notranslate"><span class="pre">public</span></code> ，<code class="docutils literal notranslate"><span class="pre">private</span></code> 或 <code class="docutils literal notranslate"><span class="pre">protected</span></code>)</p>
<dl class="directive">
<dt id="directive-cpp:class">
<code class="descname">.. cpp:class::</code><code class="descclassname"> class specifier</code><a class="headerlink" href="#directive-cpp:class" title="永久链接至目标">¶</a></dt>
<dt id="directive-cpp:struct">
<code class="descname">.. cpp:struct::</code><code class="descclassname"> class specifier</code><a class="headerlink" href="#directive-cpp:struct" title="永久链接至目标">¶</a></dt>
<dd><p>描述一个类/结构，可能带有继承规范，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> MyClass : public MyBase, MyOtherBase
</pre></div>
</div>
<p>区别 <a class="reference internal" href="#directive-cpp:class" title="cpp:class directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">cpp:class</span></code></a> 和 <a class="reference internal" href="#directive-cpp:struct" title="cpp:struct directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">cpp:struct</span></code></a> 只是装饰:输出中呈现的前缀，以及索引中显示的说明符。</p>
<p>该类可以直接在嵌套范围内声明，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> OuterScope::MyClass : public MyBase, MyOtherBase
</pre></div>
</div>
<p>可以声明一个类模板:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;typename T, std::size_t N&gt; std::array
</pre></div>
</div>
<p>或者换行:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;typename T, std::size_t N&gt; \
               std::array
</pre></div>
</div>
<p>可以声明完整和部分模板特化:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;&gt; \
               std::array&lt;bool, 256&gt;

<span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;typename T&gt; \
               std::array&lt;T, 42&gt;
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">2.0 新版功能: </span><a class="reference internal" href="#directive-cpp:struct" title="cpp:struct directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">cpp:struct</span></code></a> 指令。</p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:function">
<code class="descname">.. cpp:function::</code><code class="descclassname"> (member) function prototype</code><a class="headerlink" href="#directive-cpp:function" title="永久链接至目标">¶</a></dt>
<dd><p>描述一个函数或成员函数，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> bool myMethod(int arg1, std::string arg2)

   A function with parameters and types.

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> bool myMethod(int, double)

   A function with unnamed parameters.

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> const T &amp;MyClass::operator[](std::size_t i) const

   An overload for the indexing operator.

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> operator bool() const

   A casting operator.

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> constexpr void foo(std::string &amp;bar[2]) noexcept

   A constexpr function.

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> MyClass::MyClass(const MyClass&amp;) = default

   A copy constructor with default implementation.
</pre></div>
</div>
<p>函数模板也可以描述:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> template&lt;typename U&gt; \
                  void print(U &amp;&amp;u)
</pre></div>
</div>
<p>和函数模板专业化:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> template&lt;&gt; \
                  void print(int i)
</pre></div>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:member">
<code class="descname">.. cpp:member::</code><code class="descclassname"> (member) variable declaration</code><a class="headerlink" href="#directive-cpp:member" title="永久链接至目标">¶</a></dt>
<dt id="directive-cpp:var">
<code class="descname">.. cpp:var::</code><code class="descclassname"> (member) variable declaration</code><a class="headerlink" href="#directive-cpp:var" title="永久链接至目标">¶</a></dt>
<dd><p>描述变量或成员变量，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:member</span><span class="p">::</span> std::string MyClass::myMember

<span class="p">..</span> <span class="ow">cpp:var</span><span class="p">::</span> std::string MyClass::myOtherMember[N][M]

<span class="p">..</span> <span class="ow">cpp:member</span><span class="p">::</span> int a = 42
</pre></div>
</div>
<p>变量模板也可以描述:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:member</span><span class="p">::</span> template&lt;class T&gt; \
                constexpr T pi = T(3.1415926535897932385)
</pre></div>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:type">
<code class="descname">.. cpp:type::</code><code class="descclassname"> typedef declaration</code><a class="headerlink" href="#directive-cpp:type" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">.. cpp:type::</code><code class="descclassname"> name</code></dt>
<dt>
<code class="descname">.. cpp:type::</code><code class="descclassname"> type alias declaration</code></dt>
<dd><p>描述typedef声明中的类型，类型别名声明，或者只是具有未指定类型的类型的名称，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:type</span><span class="p">::</span> std::vector&lt;int&gt; MyList

   A typedef-like declaration of a type.

<span class="p">..</span> <span class="ow">cpp:type</span><span class="p">::</span> MyContainer::const_iterator

   Declaration of a type alias with unspecified type.

<span class="p">..</span> <span class="ow">cpp:type</span><span class="p">::</span> MyType = std::unordered_map&lt;int, std::string&gt;

   Declaration of a type alias.
</pre></div>
</div>
<p>类型别名也可以模板化:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:type</span><span class="p">::</span> template&lt;typename T&gt; \
              MyContainer = std::vector&lt;T&gt;
</pre></div>
</div>
<p>该示例呈现如下。</p>
<dl class="type">
<dt id="_CPPv46MyList">
<span id="_CPPv36MyList"></span><span id="_CPPv26MyList"></span><span id="MyList"></span><em class="property">typedef </em>std::vector&lt;int&gt; <code class="descname">MyList</code><a class="headerlink" href="#_CPPv46MyList" title="永久链接至目标">¶</a><br /></dt>
<dd><p>类型的typedef式声明。</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv4N11MyContainer14const_iteratorE">
<span id="_CPPv3N11MyContainer14const_iteratorE"></span><span id="_CPPv2N11MyContainer14const_iteratorE"></span><span id="MyContainer::const_iterator"></span><em class="property">type </em><code class="descclassname">MyContainer<code class="descclassname">::</code></code><code class="descname">const_iterator</code><a class="headerlink" href="#_CPPv4N11MyContainer14const_iteratorE" title="永久链接至目标">¶</a><br /></dt>
<dd><p>声明具有未指定类型的类型别名。</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv46MyType">
<span id="_CPPv36MyType"></span><span id="_CPPv26MyType"></span><em class="property">using </em><code class="descname">MyType</code> = std::unordered_map&lt;int, std::string&gt;<a class="headerlink" href="#_CPPv46MyType" title="永久链接至目标">¶</a><br /></dt>
<dd><p>声明类型别名。</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv4I0E11MyContainer">
<span id="_CPPv3I0E11MyContainer"></span><span id="_CPPv2I0E11MyContainer"></span>template&lt;typename <code class="descname">T</code>&gt;<br /><em class="property">using </em><code class="descname">MyContainer</code> = std::vector&lt;<a class="reference internal" href="#_CPPv4I0E11MyContainer" title="MyContainer::T">T</a>&gt;<a class="headerlink" href="#_CPPv4I0E11MyContainer" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="directive">
<dt id="directive-cpp:enum">
<code class="descname">.. cpp:enum::</code><code class="descclassname"> unscoped enum declaration</code><a class="headerlink" href="#directive-cpp:enum" title="永久链接至目标">¶</a></dt>
<dt id="directive-cpp:enum-struct">
<code class="descname">.. cpp:enum-struct::</code><code class="descclassname"> scoped enum declaration</code><a class="headerlink" href="#directive-cpp:enum-struct" title="永久链接至目标">¶</a></dt>
<dt id="directive-cpp:enum-class">
<code class="descname">.. cpp:enum-class::</code><code class="descclassname"> scoped enum declaration</code><a class="headerlink" href="#directive-cpp:enum-class" title="永久链接至目标">¶</a></dt>
<dd><p>描述(范围)枚举，可能具有指定的基础类型。在unscoped枚举中声明的任何枚举器都将在枚举范围和父范围内声明。例子:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:enum</span><span class="p">::</span> MyEnum

   An unscoped enum.

<span class="p">..</span> <span class="ow">cpp:enum</span><span class="p">::</span> MySpecificEnum : long

   An unscoped enum with specified underlying type.

<span class="p">..</span> <span class="ow">cpp:enum-class</span><span class="p">::</span> MyScopedEnum

   A scoped enum.

<span class="p">..</span> <span class="ow">cpp:enum-struct</span><span class="p">::</span> protected MyScopedVisibilityEnum : std::underlying_type&lt;MySpecificEnum&gt;::type

   A scoped enum with non-default visibility, and with a specified underlying type.
</pre></div>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:enumerator">
<code class="descname">.. cpp:enumerator::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-cpp:enumerator" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">.. cpp:enumerator::</code><code class="descclassname"> name = constant</code></dt>
<dd><p>描述一个枚举器，可选择定义其值，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:enumerator</span><span class="p">::</span> MyEnum::myEnumerator

<span class="p">..</span> <span class="ow">cpp:enumerator</span><span class="p">::</span> MyEnum::myOtherEnumerator = 42
</pre></div>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:union">
<code class="descname">.. cpp:union::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-cpp:union" title="永久链接至目标">¶</a></dt>
<dd><p>描述一个联盟。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:concept">
<code class="descname">.. cpp:concept::</code><code class="descclassname"> template-parameter-list name</code><a class="headerlink" href="#directive-cpp:concept" title="永久链接至目标">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">警告</p>
<p>对概念的支持是实验性的。它基于当前的标准草案和概念技术规范。这些功能可能随着它们的发展而变化。</p>
</div>
<p>描述一个概念。它必须有1个模板参数列表。名称可以是嵌套名称。例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:concept</span><span class="p">::</span> template&lt;typename It&gt; std::Iterator

   Proxy to an element of a notional sequence that can be compared,
   indirected, or incremented.

   <span class="gs">**Notation**</span>

<span class="p">   ..</span> <span class="ow">cpp:var</span><span class="p">::</span> It r

      An lvalue.

   <span class="gs">**Valid Expressions**</span>

   <span class="m">-</span> <span class="na">:cpp:expr:</span><span class="nv">`*r`</span>, when <span class="na">:cpp:expr:</span><span class="nv">`r`</span> is dereferenceable.
   <span class="m">-</span> <span class="na">:cpp:expr:</span><span class="nv">`++r`</span>, with return type <span class="na">:cpp:expr:</span><span class="nv">`It&amp;`</span>, when <span class="na">:cpp:expr:</span><span class="nv">`r`</span> is incrementable.
</pre></div>
</div>
<p>这将呈现如下:</p>
<dl class="concept">
<dt id="_CPPv4I0ENSt8IteratorE">
<span id="_CPPv3I0ENSt8IteratorE"></span><span id="_CPPv2I0ENSt8IteratorE"></span>template&lt;typename <code class="descname">It</code>&gt;<br /><em class="property">concept </em><code class="descclassname">std<code class="descclassname">::</code></code><code class="descname">Iterator</code><a class="headerlink" href="#_CPPv4I0ENSt8IteratorE" title="永久链接至目标">¶</a><br /></dt>
<dd><p>代理到可以比较，间接或增量的有理序列的元素。</p>
<p><strong>Notation</strong></p>
<dl class="var">
<dt id="_CPPv4NSt8Iterator1rE">
<span id="_CPPv3NSt8Iterator1rE"></span><span id="_CPPv2NSt8Iterator1rE"></span><span id="std::Iterator::r__It"></span><a class="reference internal" href="#_CPPv4I0ENSt8IteratorE" title="std::Iterator::It">It</a> <code class="descname">r</code><a class="headerlink" href="#_CPPv4NSt8Iterator1rE" title="永久链接至目标">¶</a><br /></dt>
<dd><p>一个左值。</p>
</dd></dl>

<p><strong>Valid Expressions</strong></p>
<ul class="simple">
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">*</span><a class="reference internal" href="#_CPPv4NSt8Iterator1rE" title="std::Iterator::r"><span class="pre">r</span></a></code>, 当 <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NSt8Iterator1rE" title="std::Iterator::r"><span class="pre">r</span></a></code> 是可解除引用的。</p></li>
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><a class="reference internal" href="#_CPPv4NSt8Iterator1rE" title="std::Iterator::r"><span class="pre">r</span></a></code> ，返回类型 <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I0ENSt8IteratorE" title="std::Iterator::It"><span class="pre">It</span></a><span class="pre">&amp;</span></code>, when <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NSt8Iterator1rE" title="std::Iterator::r"><span class="pre">r</span></a></code> 是可递增的。</p></li>
</ul>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">1.5 新版功能.</span></p>
</div>
</dd></dl>

<div class="section" id="options">
<h4>选项<a class="headerlink" href="#options" title="永久链接至标题">¶</a></h4>
<p>一些指令支持选项:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">:noindex:</span></code> , 看到 <a class="reference internal" href="#basic-domain-markup"><span class="std std-ref">基本标记</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:tparam-line-spec:</span></code> ，用于模板化声明。如果指定，则每个模板参数将在单独的行上呈现。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.6 新版功能.</span></p>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="anonymous-entities">
<h3>匿名实体<a class="headerlink" href="#anonymous-entities" title="永久链接至标题">¶</a></h3>
<p>C++  支持匿名命名空间，类，枚举和联合。为了文档起见，必须给它们一些以 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 开头的名字，例如 <code class="docutils literal notranslate"><span class="pre">&#64;42</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&#64;data</span></code> 。这些名称也可用于交叉引用和(类型)表达式，但即使省略也会找到嵌套符号。 <code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">...</span></code> 名称将始终显示为 <strong>[anonymous]</strong> (可能作为链接)。</p>
<p>例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> Data

<span class="p">   ..</span> <span class="ow">cpp:union</span><span class="p">::</span> @data

<span class="p">      ..</span> <span class="ow">cpp:var</span><span class="p">::</span> int a

<span class="p">      ..</span> <span class="ow">cpp:var</span><span class="p">::</span> double b

Explicit ref: <span class="na">:cpp:var:</span><span class="nv">`Data::@data::a`</span>. Short-hand ref: <span class="na">:cpp:var:</span><span class="nv">`Data::a`</span>.
</pre></div>
</div>
<p>这将呈现为:</p>
<dl class="class">
<dt id="_CPPv44Data">
<span id="_CPPv34Data"></span><span id="_CPPv24Data"></span><span id="Data"></span><em class="property">class </em><code class="descname">Data</code><a class="headerlink" href="#_CPPv44Data" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="union">
<dt id="_CPPv4N4DataUt4_dataE">
<span id="_CPPv3N4DataUt4_dataE"></span><em class="property">union </em><strong>[anonymous]</strong><a class="headerlink" href="#_CPPv4N4DataUt4_dataE" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="var">
<dt id="_CPPv4N4DataUt4_data1aE">
<span id="_CPPv3N4DataUt4_data1aE"></span>int <code class="descname">a</code><a class="headerlink" href="#_CPPv4N4DataUt4_data1aE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<dl class="var">
<dt id="_CPPv4N4DataUt4_data1bE">
<span id="_CPPv3N4DataUt4_data1bE"></span>double <code class="descname">b</code><a class="headerlink" href="#_CPPv4N4DataUt4_data1bE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<p>显式ref: <a class="reference internal" href="#_CPPv4N4DataUt4_data1aE" title="Data::[anonymous]::a"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">Data::[anonymous]::a</span></code></a> 。简写ref: <a class="reference internal" href="#_CPPv4N4DataUt4_data1aE" title="Data::[anonymous]::a"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">Data::a</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</div>
<div class="section" id="aliasing-declarations">
<h3>别名声明<a class="headerlink" href="#aliasing-declarations" title="永久链接至标题">¶</a></h3>
<p>有时，除了主要文档之外，它可能是有用的列表声明，例如，在创建类接口的概要时。以下指令可用于此目的。</p>
<dl class="directive">
<dt id="directive-cpp:alias">
<code class="descname">.. cpp:alias::</code><code class="descclassname"> name or function signature</code><a class="headerlink" href="#directive-cpp:alias" title="永久链接至目标">¶</a></dt>
<dd><p>插入一个或多个别名声明。可以在 <a class="reference internal" href="#role-cpp:any" title="cpp:any role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:any</span></code></a> 角色中指定每个实体。如果给出了函数的名称(而不是完整的签名)，那么将列出函数的所有重载。</p>
<p>例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:alias</span><span class="p">::</span> Data::a
               overload_example::C::f
</pre></div>
</div>
<p>becomes</p>
<dl class="alias">
<dt>
int <a class="reference internal" href="#_CPPv4N4DataUt4_data1aE" title="Data::[anonymous]::a">a</a><br /></dt>
<dt>
void <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f">f</a><span class="sig-paren">(</span>double d<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dt>
void <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f">f</a><span class="sig-paren">(</span>double d<span class="sig-paren">)</span><br /></dt>
<dt>
void <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f">f</a><span class="sig-paren">(</span>int i<span class="sig-paren">)</span><br /></dt>
<dt>
void <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f">f</a><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<p>whereas:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:alias</span><span class="p">::</span> void overload_example::C::f(double d) const
               void overload_example::C::f(double d)
</pre></div>
</div>
<p>becomes</p>
<dl class="alias">
<dt>
void <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f">f</a><span class="sig-paren">(</span>double d<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dt>
void <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f">f</a><span class="sig-paren">(</span>double d<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">2.0 新版功能.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="constrained-templates">
<h3>约束模板<a class="headerlink" href="#constrained-templates" title="永久链接至标题">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>对概念的支持是实验性的。它基于当前的标准草案和概念技术规范。这些功能可能随着它们的发展而变化。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Sphinx目前不支持 <code class="docutils literal notranslate"><span class="pre">requires</span></code> 条款。</p>
</div>
<div class="section" id="placeholders">
<h4>占位符<a class="headerlink" href="#placeholders" title="永久链接至标题">¶</a></h4>
<p>声明可以使用概念的名称来引入受约束的模板参数，或者使用关键字“auto”来引入无约束的模板参数:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> void f(auto &amp;&amp;arg)

   A function template with a single unconstrained template parameter.

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> void f(std::Iterator it)

   A function template with a single template parameter, constrained by the
   Iterator concept.
</pre></div>
</div>
</div>
<div class="section" id="template-introductions">
<h4>模板介绍<a class="headerlink" href="#template-introductions" title="永久链接至标题">¶</a></h4>
<p>可以使用 <cite>template introduction</cite> 而不是模板参数列表声明简单约束函数或类模板:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> std::Iterator{It} void advance(It &amp;it)

    A function template with a template parameter constrained to be an
    Iterator.

<span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> std::LessThanComparable{T} MySortedContainer

    A class template with a template parameter constrained to be
    LessThanComparable.
</pre></div>
</div>
<p>它们呈现如下。</p>
<dl class="function">
<dt id="_CPPv4I0EXNSt8IteratorEI2ItEE7advancevR2It">
<span id="_CPPv3I0EXNSt8IteratorEI2ItEE7advanceR2It"></span><span id="_CPPv2I0EXNSt8IteratorEI2ItEE7advanceR2It"></span>std::<a class="reference internal" href="#_CPPv4I0ENSt8IteratorE" title="std::Iterator">Iterator</a>{<code class="descname">It</code>}<br />void <code class="descname">advance</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EXNSt8IteratorEI2ItEE7advancevR2It" title="advance::It">It</a> &amp;<em>it</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EXNSt8IteratorEI2ItEE7advancevR2It" title="永久链接至目标">¶</a><br /></dt>
<dd><p>具有模板参数的函数模板被约束为迭代器。</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EXNSt18LessThanComparableEI1TEE17MySortedContainer">
<span id="_CPPv3I0EXNSt18LessThanComparableEI1TEE17MySortedContainer"></span><span id="_CPPv2I0EXNSt18LessThanComparableEI1TEE17MySortedContainer"></span>std::LessThanComparable{<code class="descname">T</code>}<br /><em class="property">class </em><code class="descname">MySortedContainer</code><a class="headerlink" href="#_CPPv4I0EXNSt18LessThanComparableEI1TEE17MySortedContainer" title="永久链接至目标">¶</a><br /></dt>
<dd><p>具有模板参数的类模板约束为 LessThanComparable。</p>
</dd></dl>

<p>但请注意，不会对参数兼容性进行检查。例如，<code class="docutils literal notranslate"><span class="pre">Iterator{A，B，C}</span></code> 将被接受作为介绍，即使它不是有效的 C++。</p>
</div>
</div>
<div class="section" id="inline-expressions-and-types">
<h3>内联表达式和类型<a class="headerlink" href="#inline-expressions-and-types" title="永久链接至标题">¶</a></h3>
<dl class="role">
<dt id="role-cpp:expr">
<code class="descname">:cpp:expr:</code><a class="headerlink" href="#role-cpp:expr" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:texpr">
<code class="descname">:cpp:texpr:</code><a class="headerlink" href="#role-cpp:texpr" title="永久链接至目标">¶</a></dt>
<dd><p>插入C++ 表达式或键入内联代码 (<code class="docutils literal notranslate"><span class="pre">cpp:expr</span></code>) 或内联文本 (<code class="docutils literal notranslate"><span class="pre">cpp:texpr</span></code>) 。例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:var</span><span class="p">::</span> int a = 42

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> int f(int i)

An expression: <span class="na">:cpp:expr:</span><span class="nv">`a * f(a)`</span> (or as text: <span class="na">:cpp:texpr:</span><span class="nv">`a * f(a)`</span>).

A type: <span class="na">:cpp:expr:</span><span class="nv">`const MySortedContainer&lt;int&gt;&amp;`</span>
(or as text <span class="na">:cpp:texpr:</span><span class="nv">`const MySortedContainer&lt;int&gt;&amp;`</span>).
</pre></div>
</div>
<p>将呈现如下:</p>
<dl class="var">
<dt id="_CPPv41a">
<span id="_CPPv31a"></span><span id="_CPPv21a"></span><span id="a__i"></span>int <code class="descname">a</code> = 42<a class="headerlink" href="#_CPPv41a" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv41fi">
<span id="_CPPv31fi"></span><span id="_CPPv21fi"></span><span id="f__i"></span>int <code class="descname">f</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv41fi" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<p>表达式: <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv41a" title="a"><span class="pre">a</span></a> <span class="pre">*</span> <a class="reference internal" href="#_CPPv41fi" title="f"><span class="pre">f</span></a><span class="pre">(</span><a class="reference internal" href="#_CPPv41a" title="a"><span class="pre">a</span></a><span class="pre">)</span></code> (或文本: <span class="xref cpp cpp-texpr"><a class="reference internal" href="#_CPPv41a" title="a">a</a> * <a class="reference internal" href="#_CPPv41fi" title="f">f</a>(<a class="reference internal" href="#_CPPv41a" title="a">a</a>)</span>)。</p>
<p>类型: <code class="xref cpp cpp-expr docutils literal notranslate"><em class="property"><span class="pre">const</span></em> <a class="reference internal" href="#_CPPv4I0EXNSt18LessThanComparableEI1TEE17MySortedContainer" title="MySortedContainer"><span class="pre">MySortedContainer</span></a><span class="pre">&lt;</span><span class="pre">int</span><span class="pre">&gt;</span><span class="pre">&amp;</span></code> (或作为文本 <span class="xref cpp cpp-texpr"><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EXNSt18LessThanComparableEI1TEE17MySortedContainer" title="MySortedContainer">MySortedContainer</a>&lt;int&gt;&amp;</span>)。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.7 新版功能: </span><a class="reference internal" href="#role-cpp:expr" title="cpp:expr role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:expr</span></code></a> 角色。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能: </span><a class="reference internal" href="#role-cpp:texpr" title="cpp:texpr role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:texpr</span></code></a> 角色。</p>
</div>
</dd></dl>

</div>
<div class="section" id="namespacing">
<h3>命名空间<a class="headerlink" href="#namespacing" title="永久链接至标题">¶</a></h3>
<p>C++ 域中的声明默认放在全局范围内。可以使用三个命名空间指令更改当前范围。他们管理堆栈声明，其中 <code class="docutils literal notranslate"><span class="pre">cpp:namespace</span></code> 重置堆栈并更改给定的范围。“</p>
<p><code class="docutils literal notranslate"><span class="pre">cpp:namespace-push</span></code> 指令将范围更改为当前范围的给定内部范围。</p>
<p><code class="docutils literal notranslate"><span class="pre">cpp:namespace-pop</span></code> 指令撤消了最新的 <code class="docutils literal notranslate"><span class="pre">cpp:namespace-push</span></code> 指令。</p>
<dl class="directive">
<dt id="directive-cpp:namespace">
<code class="descname">.. cpp:namespace::</code><code class="descclassname"> scope specification</code><a class="headerlink" href="#directive-cpp:namespace" title="永久链接至目标">¶</a></dt>
<dd><p>将后续对象的当前范围更改为给定范围，并重置命名空间指令堆栈。请注意，命名空间不需要与C++ 命名空间相对应，但可以以类的名称结尾，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:namespace</span><span class="p">::</span> Namespace1::Namespace2::SomeClass::AnInnerClass
</pre></div>
</div>
<p>将定义所有后续对象，就好像它们的名称是在前置范围的情况下声明的一样。将在当前范围中搜索后续交叉引用。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 作为范围将变为全局范围。</p>
<p>命名空间声明也可以模板化，例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;typename T&gt; \
               std::vector

<span class="p">..</span> <span class="ow">cpp:namespace</span><span class="p">::</span> template&lt;typename T&gt; std::vector

<span class="p">..</span> <span class="ow">cpp:function</span><span class="p">::</span> std::size_t size() const
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">size</span></code> 声明为类模板 <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">::</span> <span class="pre">vector</span></code> 的成员函数。等价地，这可以使用:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;typename T&gt; \
               std::vector

<span class="p">   ..</span> <span class="ow">cpp:function</span><span class="p">::</span> std::size_t size() const
</pre></div>
</div>
<p>要么:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:class</span><span class="p">::</span> template&lt;typename T&gt; \
               std::vector
</pre></div>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:namespace-push">
<code class="descname">.. cpp:namespace-push::</code><code class="descclassname"> scope specification</code><a class="headerlink" href="#directive-cpp:namespace-push" title="永久链接至目标">¶</a></dt>
<dd><p>相对于当前范围更改范围。例如，之后:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:namespace</span><span class="p">::</span> A::B

<span class="p">..</span> <span class="ow">cpp:namespace-push</span><span class="p">::</span> C::D
</pre></div>
</div>
<p>the current scope will be <code class="docutils literal notranslate"><span class="pre">A::B::C::D</span></code> .</p>
<div class="versionadded">
<p><span class="versionmodified added">1.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-cpp:namespace-pop">
<code class="descname">.. cpp:namespace-pop::</code><code class="descclassname"> </code><a class="headerlink" href="#directive-cpp:namespace-pop" title="永久链接至目标">¶</a></dt>
<dd><p>撤消之前的 <code class="docutils literal notranslate"><span class="pre">cpp:namespace-push</span></code> 指令(<em>not</em> 只是弹出作用域)。例如，之后:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:namespace</span><span class="p">::</span> A::B

<span class="p">..</span> <span class="ow">cpp:namespace-push</span><span class="p">::</span> C::D

<span class="p">..</span> <span class="ow">cpp:namespace-pop</span><span class="p">::</span>
</pre></div>
</div>
<p>当前范围将是 <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">::</span> <span class="pre">B</span></code> (<em>not</em> <code class="docutils literal notranslate"><span class="pre">A::B::C</span></code>)。</p>
<p>如果没有使用先前的 <code class="docutils literal notranslate"><span class="pre">cpp:namespace-push</span></code> 指令，但只使用 <code class="docutils literal notranslate"><span class="pre">cpp:namespace</span></code> 指令，则当前作用域将重置为全局作用域。也就是说，<code class="docutils literal notranslate"><span class="pre">cpp:namespace</span> <span class="pre">::</span> <span class="pre">A</span> <span class="pre">::</span> <span class="pre">B</span></code> 相当于:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">cpp:namespace</span><span class="p">::</span> nullptr

<span class="p">..</span> <span class="ow">cpp:namespace-push</span><span class="p">::</span> A::B
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">1.4 新版功能.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>信息字段列表<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>C++ 指令支持以下信息字段(另请参阅 <a class="reference internal" href="#info-field-lists"><span class="std std-ref">信息字段列表</span></a> ):</p>
<ul class="simple">
<li><p><cite>param</cite>, <cite>parameter</cite>, <cite>arg</cite>, <cite>argument</cite>: 参数说明。</p></li>
<li><p><cite>tparam</cite>:模板参数的描述。</p></li>
<li><p><cite>returns</cite>, <cite>return</cite>:返回值的描述。</p></li>
<li><p><cite>throws</cite>, <cite>throw</cite>, <cite>exception</cite>: 可能抛出的异常的描述。</p></li>
</ul>
</div>
<div class="section" id="cross-referencing">
<span id="cpp-roles"></span><h3>交叉引用<a class="headerlink" href="#cross-referencing" title="永久链接至标题">¶</a></h3>
<p>这些角色链接到给定的声明类型:</p>
<dl class="role">
<dt id="role-cpp:any">
<code class="descname">:cpp:any:</code><a class="headerlink" href="#role-cpp:any" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:class">
<code class="descname">:cpp:class:</code><a class="headerlink" href="#role-cpp:class" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:struct">
<code class="descname">:cpp:struct:</code><a class="headerlink" href="#role-cpp:struct" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:func">
<code class="descname">:cpp:func:</code><a class="headerlink" href="#role-cpp:func" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:member">
<code class="descname">:cpp:member:</code><a class="headerlink" href="#role-cpp:member" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:var">
<code class="descname">:cpp:var:</code><a class="headerlink" href="#role-cpp:var" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:type">
<code class="descname">:cpp:type:</code><a class="headerlink" href="#role-cpp:type" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:concept">
<code class="descname">:cpp:concept:</code><a class="headerlink" href="#role-cpp:concept" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:enum">
<code class="descname">:cpp:enum:</code><a class="headerlink" href="#role-cpp:enum" title="永久链接至目标">¶</a></dt>
<dt id="role-cpp:enumerator">
<code class="descname">:cpp:enumerator:</code><a class="headerlink" href="#role-cpp:enumerator" title="永久链接至目标">¶</a></dt>
<dd><p>按名称引用C++ 声明(有关详细信息，请参见下文)。名称必须相对于链接的位置适当限定。</p>
<div class="versionadded">
<p><span class="versionmodified added">2.0 新版功能: </span><a class="reference internal" href="#role-cpp:struct" title="cpp:struct role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:struct</span></code></a> 角色充当 <a class="reference internal" href="#role-cpp:class" title="cpp:class role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:class</span></code></a> 角色的别名。</p>
</div>
</dd></dl>

<div class="admonition-note-on-references-with-templates-parameters-arguments admonition">
<p class="admonition-title">有关模板参数/参数的引用的注释</p>
<p>这些角色遵循Sphinx <a class="reference internal" href="roles.html#xref-syntax"><span class="std std-ref">交叉引用语法</span></a> 规则。这意味着在引用(部分)模板专业化时必须小心，例如:如果链接看起来像这样: <code class="docutils literal notranslate"><span class="pre">:cpp:class:`MyClass</span> <span class="pre">&lt;int&gt;`</span></code> 。这被解释为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的链接，标题为 <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 。在这种情况下，用反斜杠转义开口尖括号，如下所示: <code class="docutils literal notranslate"><span class="pre">:cpp:class:`MyClass\&lt;int&gt;`</span></code> 。</p>
<p>当不需要自定义标题时，使用内联表达式的角色可能很有用 <a class="reference internal" href="#role-cpp:expr" title="cpp:expr role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:expr</span></code></a> 和 <a class="reference internal" href="#role-cpp:texpr" title="cpp:texpr role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:texpr</span></code></a> ，其中尖括号不需要转义。</p>
</div>
<div class="section" id="declarations-without-template-parameters-and-template-arguments">
<h4>没有模板参数和模板参数的声明<a class="headerlink" href="#declarations-without-template-parameters-and-template-arguments" title="永久链接至标题">¶</a></h4>
<p>对于链接到非模板化声明，名称必须是嵌套名称，例如 <code class="docutils literal notranslate"><span class="pre">f</span></code> 或 <code class="docutils literal notranslate"><span class="pre">MyClass::f</span></code> 。</p>
</div>
<div class="section" id="overloaded-member-functions">
<h4>重载(成员)函数<a class="headerlink" href="#overloaded-member-functions" title="永久链接至标题">¶</a></h4>
<p>当仅使用其名称引用(成员)函数时，引用将指向任意匹配的重载。 <a class="reference internal" href="#role-cpp:any" title="cpp:any role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:any</span></code></a> 和 <a class="reference internal" href="#role-cpp:func" title="cpp:func role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:func</span></code></a> roles 使用另一种格式，它只是一个完整的函数声明。这将解决完全匹配的重载。例如，请考虑以下类声明:</p>
<dl class="class">
<dt id="_CPPv4N16overload_example1CE">
<span id="_CPPv3N16overload_example1CE"></span><span id="_CPPv2N16overload_example1CE"></span><span id="overload_example::C"></span><em class="property">class </em><code class="descname">C</code><a class="headerlink" href="#_CPPv4N16overload_example1CE" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="function">
<dt id="_CPPv4NK16overload_example1C1fEd">
<span id="_CPPv3NK16overload_example1C1fEd"></span><span id="_CPPv2NK16overload_example1C1fEd"></span><span id="overload_example::C::f__doubleC"></span>void <code class="descname">f</code><span class="sig-paren">(</span>double <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK16overload_example1C1fEd" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16overload_example1C1fEd">
<span id="_CPPv3N16overload_example1C1fEd"></span><span id="_CPPv2N16overload_example1C1fEd"></span><span id="overload_example::C::f__double"></span>void <code class="descname">f</code><span class="sig-paren">(</span>double <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16overload_example1C1fEd" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16overload_example1C1fEi">
<span id="_CPPv3N16overload_example1C1fEi"></span><span id="_CPPv2N16overload_example1C1fEi"></span><span id="overload_example::C::f__i"></span>void <code class="descname">f</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16overload_example1C1fEi" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16overload_example1C1fEv">
<span id="_CPPv3N16overload_example1C1fEv"></span><span id="_CPPv2N16overload_example1C1fEv"></span><span id="overload_example::C::f"></span>void <code class="descname">f</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16overload_example1C1fEv" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<p>引用使用 <a class="reference internal" href="#role-cpp:func" title="cpp:func role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">cpp:func</span></code></a> 角色:</p>
<ul class="simple">
<li><p>任意重载: <code class="docutils literal notranslate"><span class="pre">C::f</span></code> ， <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">C::f()</span></code></a></p></li>
<li><p>Also arbitrary overload: <code class="docutils literal notranslate"><span class="pre">C::f()</span></code>, <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="overload_example::C::f"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">C::f()</span></code></a></p></li>
<li><p>特定的重载: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f()</span></code> ， <a class="reference internal" href="#_CPPv4N16overload_example1C1fEv" title="void C::f()"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f()</span></code></a></p></li>
<li><p>具体超负荷: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f(int)</span></code>,  <a class="reference internal" href="#_CPPv4N16overload_example1C1fEi" title="void C::f(int)"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f(int)</span></code></a></p></li>
<li><p>具体超负荷: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f(double)</span></code> ,  <a class="reference internal" href="#_CPPv4N16overload_example1C1fEd" title="void C::f(double)"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f(double)</span></code></a></p></li>
<li><p>具体超负荷: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f(double)</span> <span class="pre">const</span></code> , <a class="reference internal" href="#_CPPv4NK16overload_example1C1fEd" title="void C::f(double) const"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">void</span> <span class="pre">C::f(double)</span> <span class="pre">const</span></code></a></p></li>
</ul>
<p>请注意 <a class="reference internal" href="../configuration.html#confval-add_function_parentheses"><code class="xref std std-confval docutils literal notranslate"><span class="pre">add_function_parentheses</span></code></a> 配置变量不会影响特定的重载引用。</p>
</div>
<div class="section" id="templated-declarations">
<h4>模板化的声明<a class="headerlink" href="#templated-declarations" title="永久链接至标题">¶</a></h4>
<p>假设以下声明。</p>
<dl class="class">
<dt id="_CPPv47Wrapper">
<span id="_CPPv37Wrapper"></span><span id="_CPPv27Wrapper"></span><span id="Wrapper"></span><em class="property">class </em><code class="descname">Wrapper</code><a class="headerlink" href="#_CPPv47Wrapper" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="class">
<dt id="_CPPv4I0EN7Wrapper5OuterE">
<span id="_CPPv3I0EN7Wrapper5OuterE"></span><span id="_CPPv2I0EN7Wrapper5OuterE"></span>template&lt;typename <code class="descname">TOuter</code>&gt;<br /><em class="property">class </em><code class="descname">Outer</code><a class="headerlink" href="#_CPPv4I0EN7Wrapper5OuterE" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="class">
<dt id="_CPPv4I0EN7Wrapper5Outer5InnerE">
<span id="_CPPv3I0EN7Wrapper5Outer5InnerE"></span><span id="_CPPv2I0EN7Wrapper5Outer5InnerE"></span>template&lt;typename <code class="descname">TInner</code>&gt;<br /><em class="property">class </em><code class="descname">Inner</code><a class="headerlink" href="#_CPPv4I0EN7Wrapper5Outer5InnerE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<p>通常，引用必须包含模板参数声明和限定名称前缀的模板参数。例如:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">template\&lt;typename</span> <span class="pre">TOuter&gt;</span> <span class="pre">Wrapper::Outer</span></code>
(<a class="reference internal" href="#_CPPv4I0EN7Wrapper5OuterE" title="Wrapper::Outer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">TOuter&gt;</span> <span class="pre">Wrapper::Outer</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">template\&lt;typename</span> <span class="pre">TOuter&gt;</span> <span class="pre">template\&lt;typename</span> <span class="pre">TInner&gt;</span> <span class="pre">Wrapper::Outer&lt;TOuter&gt;::Inner</span></code>
(<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">TOuter&gt;</span> <span class="pre">template&lt;typename</span> <span class="pre">TInner&gt;</span> <span class="pre">Wrapper::Outer&lt;TOuter&gt;::Inner</span></code>)</p></li>
</ul>
<p>目前，如果模板参数标识符是相等的字符串，则查找仅成功。也就是说，<code class="docutils literal notranslate"><span class="pre">template\&lt;typename</span> <span class="pre">UOuter&gt;</span> <span class="pre">Wrapper</span> <span class="pre">::</span> <span class="pre">Outer</span></code> 将不起作用。</p>
<p>作为简写表示法，如果省略模板参数列表，则查找将采用主模板或非模板，而不是部分模板特化。这意味着以下参考资料也有效:“</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Wrapper::Outer</span></code>
(<a class="reference internal" href="#_CPPv4I0EN7Wrapper5OuterE" title="Wrapper::Outer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Wrapper::Outer</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Wrapper::Outer::Inner</span></code>
(<a class="reference internal" href="#_CPPv4I0EN7Wrapper5Outer5InnerE" title="Wrapper::Outer::Inner"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Wrapper::Outer::Inner</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">template\&lt;typename</span> <span class="pre">TInner&gt;</span> <span class="pre">Wrapper::Outer::Inner</span></code>
(<a class="reference internal" href="#_CPPv4I0EN7Wrapper5Outer5InnerE" title="Wrapper::Outer::Inner"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">TInner&gt;</span> <span class="pre">Wrapper::Outer::Inner</span></code></a>)</p></li>
</ul>
</div>
<div class="section" id="full-template-specialisations">
<h4>(完整)模板专业化<a class="headerlink" href="#full-template-specialisations" title="永久链接至标题">¶</a></h4>
<p>假设以下声明。</p>
<dl class="class">
<dt id="_CPPv4I0E5Outer">
<span id="_CPPv3I0E5Outer"></span><span id="_CPPv2I0E5Outer"></span>template&lt;typename <code class="descname">TOuter</code>&gt;<br /><em class="property">class </em><code class="descname">Outer</code><a class="headerlink" href="#_CPPv4I0E5Outer" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="class">
<dt id="_CPPv4I0EN5Outer5InnerE">
<span id="_CPPv3I0EN5Outer5InnerE"></span><span id="_CPPv2I0EN5Outer5InnerE"></span>template&lt;typename <code class="descname">TInner</code>&gt;<br /><em class="property">class </em><code class="descname">Inner</code><a class="headerlink" href="#_CPPv4I0EN5Outer5InnerE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="_CPPv4IE5OuterIiE">
<span id="_CPPv3IE5OuterIiE"></span><span id="_CPPv2IE5OuterIiE"></span>template&lt;&gt;<br /><em class="property">class </em><code class="descname">Outer</code>&lt;int&gt;<a class="headerlink" href="#_CPPv4IE5OuterIiE" title="永久链接至目标">¶</a><br /></dt>
<dd><dl class="class">
<dt id="_CPPv4I0EN5OuterIiE5InnerE">
<span id="_CPPv3I0EN5OuterIiE5InnerE"></span><span id="_CPPv2I0EN5OuterIiE5InnerE"></span>template&lt;typename <code class="descname">TInner</code>&gt;<br /><em class="property">class </em><code class="descname">Inner</code><a class="headerlink" href="#_CPPv4I0EN5OuterIiE5InnerE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv4IEN5OuterIiE5InnerIbEE">
<span id="_CPPv3IEN5OuterIiE5InnerIbEE"></span><span id="_CPPv2IEN5OuterIiE5InnerIbEE"></span>template&lt;&gt;<br /><em class="property">class </em><code class="descname">Inner</code>&lt;bool&gt;<a class="headerlink" href="#_CPPv4IEN5OuterIiE5InnerIbEE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<p>通常，引用必须包含每个模板参数列表的模板参数列表。 因此可以参考上面的完整专业化 <code class="docutils literal notranslate"><span class="pre">template\&lt;&gt;</span> <span class="pre">Outer\&lt;int&gt;</span></code> (<a class="reference internal" href="#_CPPv4IE5OuterIiE" title="Outer&lt;int&gt;"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;&gt;</span> <span class="pre">Outer&lt;int&gt;</span></code></a>) and <code class="docutils literal notranslate"><span class="pre">template\&lt;&gt;</span> <span class="pre">template\&lt;&gt;</span> <span class="pre">Outer\&lt;int&gt;::Inner\&lt;bool&gt;</span></code> (<a class="reference internal" href="#_CPPv4IEN5OuterIiE5InnerIbEE" title="Outer&lt;int&gt;::Inner&lt;bool&gt;"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;&gt;</span> <span class="pre">template&lt;&gt;</span> <span class="pre">Outer&lt;int&gt;::Inner&lt;bool&gt;</span></code></a>).  作为简写，可以省略空模板参数列表，例如， <code class="docutils literal notranslate"><span class="pre">Outer\&lt;int&gt;</span></code> (<a class="reference internal" href="#_CPPv4IE5OuterIiE" title="Outer&lt;int&gt;"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Outer&lt;int&gt;</span></code></a>) and <code class="docutils literal notranslate"><span class="pre">Outer\&lt;int&gt;::Inner\&lt;bool&gt;</span></code> (<a class="reference internal" href="#_CPPv4IEN5OuterIiE5InnerIbEE" title="Outer&lt;int&gt;::Inner&lt;bool&gt;"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Outer&lt;int&gt;::Inner&lt;bool&gt;</span></code></a>).</p>
</div>
<div class="section" id="partial-template-specialisations">
<h4>部分模板专业化<a class="headerlink" href="#partial-template-specialisations" title="永久链接至标题">¶</a></h4>
<p>假设以下声明。</p>
<dl class="class">
<dt id="_CPPv4I0E5OuterIP1TE">
<span id="_CPPv3I0E5OuterIP1TE"></span><span id="_CPPv2I0E5OuterIP1TE"></span>template&lt;typename <code class="descname">T</code>&gt;<br /><em class="property">class </em><code class="descname">Outer</code>&lt;<a class="reference internal" href="#_CPPv4I0E5OuterIP1TE" title="Outer&lt;T *&gt;::T">T</a> *&gt;<a class="headerlink" href="#_CPPv4I0E5OuterIP1TE" title="永久链接至目标">¶</a><br /></dt>
<dd></dd></dl>

<p>对部分特化的引用必须始终包含模板参数列表，例如 <code class="docutils literal notranslate"><span class="pre">template\&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">Outer\&lt;T</span> <span class="pre">*&gt;</span></code> (<a class="reference internal" href="#_CPPv4I0E5OuterIP1TE" title="Outer&lt;T *&gt;"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">Outer&lt;</span> <span class="pre">T</span> <span class="pre">*&gt;</span></code></a>)。目前，只有当模板参数标识符是相等的字符串时，查找才会成功。“</p>
</div>
</div>
<div class="section" id="configuration-variables">
<h3>配置变量<a class="headerlink" href="#configuration-variables" title="永久链接至标题">¶</a></h3>
<p>请参阅 <a class="reference internal" href="../configuration.html#cpp-config"><span class="std std-ref">C++ 域选项</span></a> 。</p>
</div>
</div>
<div class="section" id="the-standard-domain">
<span id="domains-std"></span><h2>标准域<a class="headerlink" href="#the-standard-domain" title="永久链接至标题">¶</a></h2>
<p>所谓的“标准”域收集所有不保证自己域名的标记。其指令和角色不以域名为前缀。</p>
<p>标准域也是使用 <a class="reference internal" href="../../extdev/appapi.html#sphinx.application.Sphinx.add_object_type" title="sphinx.application.Sphinx.add_object_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_object_type()</span></code></a> API添加的自定义对象描述的位置。“</p>
<p>有一组指令允许记录命令行程序:</p>
<dl class="directive">
<dt id="directive-option">
<code class="descname">.. option::</code><code class="descclassname"> name args, name args, ...</code><a class="headerlink" href="#directive-option" title="永久链接至目标">¶</a></dt>
<dd><p>描述命令行参数或开关。选项参数名称应括在尖括号中。例子:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">option</span><span class="p">::</span> dest_dir

   Destination directory.

<span class="p">..</span> <span class="ow">option</span><span class="p">::</span> -m &lt;module&gt;, --module &lt;module&gt;

   Run a module as a script.
</pre></div>
</div>
<p>该指令将为给定的选项创建交叉引用目标，可通过以下方式引用 <a class="reference internal" href="roles.html#role-option" title="option role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">option</span></code></a> (在示例中，您将使用类似 <code class="docutils literal notranslate"><span class="pre">:option:`dest_dir`</span></code> , <code class="docutils literal notranslate"><span class="pre">:option:`-m`</span></code> , 要么  <code class="docutils literal notranslate"><span class="pre">:option:`--module`</span></code>)。</p>
<p><code class="docutils literal notranslate"><span class="pre">cmdoption</span></code> 指令是 <code class="docutils literal notranslate"><span class="pre">option</span></code> 指令的弃用别名。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-envvar">
<code class="descname">.. envvar::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-envvar" title="永久链接至目标">¶</a></dt>
<dd><p>描述文档化代码或程序使用或定义的环境变量。可引用者 <a class="reference internal" href="roles.html#role-envvar" title="envvar role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">envvar</span></code></a> 。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-program">
<code class="descname">.. program::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-program" title="永久链接至目标">¶</a></dt>
<dd><p>像 <a class="reference internal" href="#directive-py:currentmodule" title="py:currentmodule directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:currentmodule</span></code></a> ，这个指令不产生输出。相反，它用于通知Sphinx所有以下内容 <a class="reference internal" href="#directive-option" title="option directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">option</span></code></a> 指令文件选项称为 <em>name</em> 。</p>
<p>如果你使用 <a class="reference internal" href="#directive-program" title="program directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">program</span></code></a> ，你必须通过程序名来限定你的 <a class="reference internal" href="roles.html#role-option" title="option role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">option</span></code></a> 角色中的引用，所以如果你有以下情况:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">program</span><span class="p">::</span> rm

<span class="p">..</span> <span class="ow">option</span><span class="p">::</span> -r

   Work recursively.

<span class="p">..</span> <span class="ow">program</span><span class="p">::</span> svn

<span class="p">..</span> <span class="ow">option</span><span class="p">::</span> -r revision

   Specify the revision to work upon.
</pre></div>
</div>
<p>然后 <code class="docutils literal notranslate"><span class="pre">:option:`rm</span> <span class="pre">-r`</span></code> 将引用第一个选项，而 <code class="docutils literal notranslate"><span class="pre">:option:`svn</span> <span class="pre">-r`</span></code> 将引用第二个选项。</p>
<p>程序名称可能包含空格(如果你想分别记录 <code class="docutils literal notranslate"><span class="pre">svn</span> <span class="pre">add</span></code> 和 <code class="docutils literal notranslate"><span class="pre">svn</span> <span class="pre">commit</span></code> 这样的子命令)。</p>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
</dd></dl>

<p>还有一个非常通用的对象描述指令，它不依赖于任何域:</p>
<dl class="directive">
<dt id="directive-describe">
<code class="descname">.. describe::</code><code class="descclassname"> text</code><a class="headerlink" href="#directive-describe" title="永久链接至目标">¶</a></dt>
<dt id="directive-object">
<code class="descname">.. object::</code><code class="descclassname"> text</code><a class="headerlink" href="#directive-object" title="永久链接至目标">¶</a></dt>
<dd><p>此伪指令生成与域提供的特定格式相同的格式，但不创建索引条目或交叉引用目标。例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">describe</span><span class="p">::</span> PAPER

   You can set this variable to select a paper size.
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="the-javascript-domain">
<h2>JavaScript域<a class="headerlink" href="#the-javascript-domain" title="永久链接至标题">¶</a></h2>
<p>JavaScript域(名称 <strong>js</strong>)提供以下指令:</p>
<dl class="directive">
<dt id="directive-js:module">
<code class="descname">.. js:module::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-js:module" title="永久链接至目标">¶</a></dt>
<dd><p>该指令设置后面的对象声明的模块名称。 模块名称用于全局模块索引和交叉引用中。 该指令不会创建如下的对象标题 <a class="reference internal" href="#directive-py:class" title="py:class directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">py:class</span></code></a> 。</p>
<p>默认情况下，此指令将创建一个可链接的实体，并将在全局模块索引中生成一个条目，除非指定了 <code class="docutils literal notranslate"><span class="pre">noindex</span></code> 选项。如果指定了此选项，则该指令将仅更新当前模块名称。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-js:function">
<code class="descname">.. js:function::</code><code class="descclassname"> name(signature)</code><a class="headerlink" href="#directive-js:function" title="永久链接至目标">¶</a></dt>
<dd><p>描述JavaScript函数或方法。如果要将参数描述为可选，请使用方括号 <a class="reference internal" href="#signatures"><span class="std std-ref">documented</span></a> 用于Python签名。</p>
<p>您可以使用字段来提供有关参数及其预期类型的​​更多详细信息，函数可能抛出的错误以及返回的值:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">js:function</span><span class="p">::</span> $.getJSON(href, callback[, errback])

   <span class="nc">:param string href:</span> <span class="nf">An URI to the location of the resource.</span>
   <span class="nc">:param callback:</span> <span class="nf">Gets called with the object.</span>
   :param errback:
       Gets called in case the request fails. And a lot of other
       text so we need multiple lines.
   <span class="nc">:throws SomeError:</span> <span class="nf">For whatever reason in that case.</span>
   <span class="nc">:returns:</span> <span class="nf">Something.</span>
</pre></div>
</div>
<p>这表现为:</p>
<blockquote>
<div><dl class="function">
<dt id="_S_.getJSON">
<code class="descclassname">$.</code><code class="descname">getJSON</code><span class="sig-paren">(</span><em>href</em>, <em>callback</em><span class="optional">[</span>, <em>errback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#_S_.getJSON" title="永久链接至目标">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">参数</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>href</strong> (<em>string</em>) – 资源位置的URI。</p></li>
<li><p><strong>callback</strong> – 使用对象调用。</p></li>
<li><p><strong>errback</strong> – 在请求失败的情况下调用。还有很多其他文字，所以我们需要多行。</p></li>
</ul>
</dd>
<dt class="field-even">抛出SomeError</dt>
<dd class="field-even"><p>无论出于何种原因。</p>
</dd>
<dt class="field-odd">返回</dt>
<dd class="field-odd"><p>某物.</p>
</dd>
</dl>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="directive">
<dt id="directive-js:method">
<code class="descname">.. js:method::</code><code class="descclassname"> name(signature)</code><a class="headerlink" href="#directive-js:method" title="永久链接至目标">¶</a></dt>
<dd><p>该指令是以下的别名 <a class="reference internal" href="#directive-js:function" title="js:function directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">js:function</span></code></a> ，但是它描述了一个作为类对象上的方法实现的函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="directive">
<dt id="directive-js:class">
<code class="descname">.. js:class::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-js:class" title="永久链接至目标">¶</a></dt>
<dd><p>描述创建对象的构造函数。这基本上就像一个函数，但会出现一个 <cite>class</cite> 前缀:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">js:class</span><span class="p">::</span> MyAnimal(name[, age])

   <span class="nc">:param string name:</span> <span class="nf">The name of the animal</span>
   <span class="nc">:param number age:</span> <span class="nf">an optional age for the animal</span>
</pre></div>
</div>
<p>这表现为:</p>
<blockquote>
<div><dl class="class">
<dt id="MyAnimal">
<em class="property">class </em><code class="descname">MyAnimal</code><span class="sig-paren">(</span><em>name</em><span class="optional">[</span>, <em>age</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#MyAnimal" title="永久链接至目标">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">参数</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>string</em>) – 动物的名字</p></li>
<li><p><strong>age</strong> (<em>number</em>) – 动物的选择年龄</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="directive">
<dt id="directive-js:data">
<code class="descname">.. js:data::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-js:data" title="永久链接至目标">¶</a></dt>
<dd><p>描述全局变量或常量。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-js:attribute">
<code class="descname">.. js:attribute::</code><code class="descclassname"> object.name</code><a class="headerlink" href="#directive-js:attribute" title="永久链接至目标">¶</a></dt>
<dd><p>描述 <em>object</em> 的属性 <em>name</em>。</p>
</dd></dl>

<p id="js-roles">提供这些角色是为了引用所描述的对象:</p>
<dl class="role">
<dt id="role-js:mod">
<code class="descname">:js:mod:</code><a class="headerlink" href="#role-js:mod" title="永久链接至目标">¶</a></dt>
<dt id="role-js:func">
<code class="descname">:js:func:</code><a class="headerlink" href="#role-js:func" title="永久链接至目标">¶</a></dt>
<dt id="role-js:meth">
<code class="descname">:js:meth:</code><a class="headerlink" href="#role-js:meth" title="永久链接至目标">¶</a></dt>
<dt id="role-js:class">
<code class="descname">:js:class:</code><a class="headerlink" href="#role-js:class" title="永久链接至目标">¶</a></dt>
<dt id="role-js:data">
<code class="descname">:js:data:</code><a class="headerlink" href="#role-js:data" title="永久链接至目标">¶</a></dt>
<dt id="role-js:attr">
<code class="descname">:js:attr:</code><a class="headerlink" href="#role-js:attr" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="the-restructuredtext-domain">
<h2>reStructuredText域<a class="headerlink" href="#the-restructuredtext-domain" title="永久链接至标题">¶</a></h2>
<p>reStructuredText域(名称 <strong>rst</strong>)提供以下指令:</p>
<dl class="directive">
<dt id="directive-rst:directive">
<code class="descname">.. rst:directive::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-rst:directive" title="永久链接至目标">¶</a></dt>
<dd><p>描述reST指令。 <em>name</em> 可以是单个指令名称或实际指令语法(<cite>..</cite> 前缀和 <cite>::</cite> 后缀)，其参数将以不同方式呈现。例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">rst:directive</span><span class="p">::</span> foo

   Foo description.

<span class="p">..</span> <span class="ow">rst:directive</span><span class="p">::</span> .. bar:: baz

   Bar description.
</pre></div>
</div>
<p>将呈现为:</p>
<blockquote>
<div><dl class="directive">
<dt id="directive-foo">
<code class="descname">.. foo::</code><a class="headerlink" href="#directive-foo" title="永久链接至目标">¶</a></dt>
<dd><p>Foo描述。</p>
</dd></dl>

<dl class="directive">
<dt id="directive-bar">
<code class="descname">.. bar::</code><code class="descclassname"> baz</code><a class="headerlink" href="#directive-bar" title="永久链接至目标">¶</a></dt>
<dd><p>Bar 描述.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="directive">
<dt id="directive-rst:role">
<code class="descname">.. rst:role::</code><code class="descclassname"> name</code><a class="headerlink" href="#directive-rst:role" title="永久链接至目标">¶</a></dt>
<dd><p>描述reST角色。例如:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">rst:role</span><span class="p">::</span> foo

   Foo description.
</pre></div>
</div>
<p>将呈现为:</p>
<blockquote>
<div><dl class="role">
<dt id="role-foo">
<code class="descname">:foo:</code><a class="headerlink" href="#role-foo" title="永久链接至目标">¶</a></dt>
<dd><p>Foo描述。</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<p id="rst-roles">提供这些角色是为了引用所描述的对象:</p>
<dl class="role">
<dt id="role-rst:dir">
<code class="descname">:rst:dir:</code><a class="headerlink" href="#role-rst:dir" title="永久链接至目标">¶</a></dt>
<dt id="role-rst:role">
<code class="descname">:rst:role:</code><a class="headerlink" href="#role-rst:role" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="the-math-domain">
<span id="math-domain"></span><h2>数学域<a class="headerlink" href="#the-math-domain" title="永久链接至标题">¶</a></h2>
<p>数学域(名称 <strong>math</strong>)提供以下角色:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">rst:role</span><span class="p">::</span> math:numref
</pre></div>
</div>
<blockquote>
<div><p>交叉引用方程的作用由以下定义 <a class="reference internal" href="directives.html#directive-math" title="math directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">math</span></code></a> 指令通过其标签定义。例:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">math</span><span class="p">::</span> e^{i\pi} + 1 = 0
   <span class="nc">:label:</span> <span class="nf">euler</span>

Euler&#39;s identity, equation <span class="na">:math:numref:</span><span class="nv">`euler`</span>, was elected one of the
most beautiful mathematical formulas.
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</div></blockquote>
</div>
<div class="section" id="more-domains">
<h2>更多域<a class="headerlink" href="#more-domains" title="永久链接至标题">¶</a></h2>
<p><a class="reference external" href="https://bitbucket.org/birkenfeld/sphinx-contrib/">sphinx-contrib</a> 存储库包含更多可用作扩展的域;目前有 <a class="reference external" href="https://pypi.org/project/sphinxcontrib-adadomain/">Ada</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-coffee/">CoffeeScript</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-erlangdomain/">Erlang</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-httpdomain/">HTTP</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-lassodomain/">Lasso</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-matlabdomain/">MATLAB</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-phpdomain/">PHP</a>, 和 <a class="reference external" href="https://bitbucket.org/birkenfeld/sphinx-contrib/src/default/rubydomain">Ruby</a> 域。另外还有 <a class="reference external" href="https://pypi.org/project/sphinxcontrib-chapeldomain/">Chapel</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-cldomain/">Common Lisp</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-dqndomain/">dqn</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-golangdomain/">Go</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-jinjadomain/">Jinja</a>, <a class="reference external" href="https://pypi.org/project/sphinxcontrib-operationdomain/">Operation</a>, 和 <a class="reference external" href="https://pypi.org/project/sphinxcontrib-scaladomain/">Scala</a> 的域。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="../markdown.html" title="Markdown"
             >下一页</a> |</li>
        <li class="right" >
          <a href="field-lists.html" title="域清单"
             >上一页</a> |</li>
<li><a href="../../index.html">主页</a>&#160;|</li>
<li><a href="../../contents.html">文档</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >reStructuredText</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2007-2019, Georg Brandl and the Sphinx team.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.0+/ec574630c 创建。
    </div>
  </body>
</html>