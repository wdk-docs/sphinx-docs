
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>应用程序API &#8212; Sphinx 2.1.0+/e678b9c34 文档</title>
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Sphinx 2.1.0+/e678b9c34 文档 中搜索"
          href="../_static/opensearch.xml"/>

    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="项目API" href="projectapi.html" />
    <link rel="prev" title="开发扩展" href="index.html" />
<link rel="canonical" href="http://www.sphinx-doc.org/en/master/extdev/appapi.html" />

<link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css' />
 
<style type="text/css">
  table.right {
    float: right;
    margin-left: 20px;
  }

  table.right td {
    border: 1px solid #ccc;
  }

    {
    % if pagename=='index'%
  }

  .related {
    display: none;
  }

    {
    % endif %
  }
</style>
<script type="text/javascript">
  // intelligent scrolling of the sidebar content
  $(window).scroll(function () {
    var sb = $('.sphinxsidebarwrapper');
    var win = $(window);
    var sbh = sb.height();
    var offset = $('.sphinxsidebar').position()['top'];
    var wintop = win.scrollTop();
    var winbot = wintop + win.innerHeight();
    var curtop = sb.position()['top'];
    var curbot = curtop + sbh;
    // does sidebar fit in window?
    if (sbh < win.innerHeight()) {
      // yes: easy case -- always keep at the top
      sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
        $(document).height() - sbh - 200
      ]));
    } else {
      // no: only scroll if top/bottom edge of sidebar is at
      // top/bottom edge of window
      if (curtop > wintop && curbot > winbot) {
        sb.css('top', $u.max([wintop - offset - 10, 0]));
      } else if (curtop < wintop && curbot < winbot) {
        sb.css('top', $u.min([winbot - sbh - offset - 20,
          $(document).height() - sbh - 200
        ]));
      }
    }
  });
</script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../index.html">主页</a></li>
    <li><a href="../usage/installation.html">安装</a></li>
    <li><a href="../contents.html">文档</a></li>
    <li><a href="../develop.html">扩展/开发</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/sphinxheader.png" alt="SPHINX" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../http-routingtable.html" title="HTTP Routing Table"
             >routing table</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="projectapi.html" title="项目API"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="开发扩展"
             accesskey="P">上一页</a> |</li>
<li><a href="../index.html">主页</a>&#160;|</li>
<li><a href="../contents.html">文档</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">开发扩展</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">应用程序API</a><ul>
<li><a class="reference internal" href="#extension-setup">扩展设置</a></li>
<li><a class="reference internal" href="#emitting-events">发出事件</a></li>
<li><a class="reference internal" href="#sphinx-runtime-information">Sphinx运行时信息</a></li>
<li><a class="reference internal" href="#sphinx-core-events">狮身人面像核心事件</a></li>
<li><a class="reference internal" href="#checking-the-sphinx-version">检查Sphinx版本</a></li>
<li><a class="reference internal" href="#the-config-object">Config对象</a></li>
<li><a class="reference internal" href="#the-template-bridge">模板桥</a></li>
<li><a class="reference internal" href="#exceptions">例外</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="index.html"
                        title="上一章">开发扩展</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="projectapi.html"
                        title="下一章">项目API</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/extdev/appapi.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-sphinx.application">
<span id="application-api"></span><h1>应用程序API<a class="headerlink" href="#module-sphinx.application" title="永久链接至标题">¶</a></h1>
<p>每个Sphinx扩展都是一个Python模块,至少有一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 函数.  在初始化时使用一个参数调用此函数,该应用程序对象表示Sphinx进程.</p>
<dl class="class">
<dt id="sphinx.application.Sphinx">
<em class="property">class </em><code class="descclassname">sphinx.application.</code><code class="descname">Sphinx</code><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx" title="永久链接至目标">¶</a></dt>
<dd><p>该应用程序对象具有下面描述的公共API.</p>
</dd></dl>

<div class="section" id="extension-setup">
<h2>扩展设置<a class="headerlink" href="#extension-setup" title="永久链接至标题">¶</a></h2>
<p>这些方法通常在扩展名的 <code class="docutils literal notranslate"><span class="pre">setup()</span></code> 函数中调用.</p>
<p>使用Sphinx扩展API的示例可以在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sphinx.ext</span></code> 包中看到.</p>
<dl class="method">
<dt id="sphinx.application.Sphinx.setup_extension">
<code class="descclassname">Sphinx.</code><code class="descname">setup_extension</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.setup_extension"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.setup_extension" title="永久链接至目标">¶</a></dt>
<dd><p>导入并设置Sphinx扩展模块.</p>
<p>加载模块 <em>name</em> 给出的扩展名.如果您的分机需要其他分机提供的功能,请使用此功能.如果被叫两次,则为无操作.</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.require_sphinx">
<code class="descclassname">Sphinx.</code><code class="descname">require_sphinx</code><span class="sig-paren">(</span><em>version</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.require_sphinx"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.require_sphinx" title="永久链接至目标">¶</a></dt>
<dd><p>如果需要,请检查Sphinx版本.</p>
<p>将 <em>version</em> (必须是 <code class="docutils literal notranslate"><span class="pre">major.minor</span></code> 版本字符串,例如 <code class="docutils literal notranslate"><span class="pre">'1.1'</span></code>)与正在运行的Sphinx的版本进行比较,并在它太旧时中止构建.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.connect">
<code class="descclassname">Sphinx.</code><code class="descname">connect</code><span class="sig-paren">(</span><em>event</em>, <em>callback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.connect"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.connect" title="永久链接至目标">¶</a></dt>
<dd><p>注册 <em>callback*在发出 *event</em> 时被调用.</p>
<p>有关可用核心事件和回调函数参数的详细信息,请参阅 <a class="reference internal" href="#events"><span class="std std-ref">狮身人面像核心事件</span></a> .</p>
<p>该方法返回一个 “listener ID” ,可用作以下参数 <a class="reference internal" href="#sphinx.application.Sphinx.disconnect" title="sphinx.application.Sphinx.disconnect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnect()</span></code></a> .</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.disconnect">
<code class="descclassname">Sphinx.</code><code class="descname">disconnect</code><span class="sig-paren">(</span><em>listener_id</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.disconnect"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.disconnect" title="永久链接至目标">¶</a></dt>
<dd><p>通过 <em>listener_id</em> 取消注册回调.</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_builder">
<code class="descclassname">Sphinx.</code><code class="descname">add_builder</code><span class="sig-paren">(</span><em>builder</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_builder"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_builder" title="永久链接至目标">¶</a></dt>
<dd><p>注册新的构建器.</p>
<p><em>builder</em> 必须是一个继承自 <a class="reference internal" href="builderapi.html#sphinx.builders.Builder" title="sphinx.builders.Builder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Builder</span></code></a> 的类.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_config_value">
<code class="descclassname">Sphinx.</code><code class="descname">add_config_value</code><span class="sig-paren">(</span><em>name</em>, <em>default</em>, <em>rebuild</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_config_value"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_config_value" title="永久链接至目标">¶</a></dt>
<dd><p>注册配置值.</p>
<p>这对于Sphinx识别新值并相应地设置默认值是必要的.*name* 应以扩展名为前缀,以避免冲突. <em>default</em> 值可以是任何 Python 对象. 字符串值 <em>rebuild</em> 必须是其中一个值:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'env'</span></code> 如果设置中的更改仅在解析文档时生效 - 这意味着必须重建整个环境.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'html'</span></code> 如果设置更改需要完全重建HTML文档.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">''</span></code> 如果设置的更改不需要任何特殊重建.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 0.6 版更改: </span>将 <em>rebuild</em> 从简单的布尔值(相当于 <code class="docutils literal notranslate"><span class="pre">''</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'env'</span></code>)更改为字符串. 但是,布尔仍然被内部接受和转换.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 0.4 版更改: </span>如果 <em>default</em> 值是可调用的,则将使用config对象作为其参数调用它以获取默认值. 这可用于实现默认值取决于其他值的配置值.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_event">
<code class="descclassname">Sphinx.</code><code class="descname">add_event</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_event"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_event" title="永久链接至目标">¶</a></dt>
<dd><p>注册名为 <em>name</em> 的活动.</p>
<p>这需要能够发射它.</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.set_translator">
<code class="descclassname">Sphinx.</code><code class="descname">set_translator</code><span class="sig-paren">(</span><em>name</em>, <em>translator_class</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.set_translator"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.set_translator" title="永久链接至目标">¶</a></dt>
<dd><p>注册或覆盖Docutils翻译课程.</p>
<p>这用于注册自定义输出转换器或替换内置转换器.  这允许扩展使用自定义转换器并为转换器定义自定义节点(请参阅 <a class="reference internal" href="#sphinx.application.Sphinx.add_node" title="sphinx.application.Sphinx.add_node"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_node()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">1.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_node">
<code class="descclassname">Sphinx.</code><code class="descname">add_node</code><span class="sig-paren">(</span><em>node</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_node"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_node" title="永久链接至目标">¶</a></dt>
<dd><p>注册Docutils节点类.</p>
<p>这对Docutils内部是必要的.  它还可以在将来用于验证解析文档中的节点.</p>
<p>Sphinx HTML,LaTeX,文本和联机帮助页面编写器的节点访问者函数可以作为关键字参数给出: 关键字应该是 <code class="docutils literal notranslate"><span class="pre">'html'</span></code> , <code class="docutils literal notranslate"><span class="pre">'latex'</span></code> , <code class="docutils literal notranslate"><span class="pre">'text'</span></code> , <code class="docutils literal notranslate"><span class="pre">'man'</span></code> , <code class="docutils literal notranslate"><span class="pre">'texinfo'</span></code> 或其他任何一个或多个支持翻译,价值是一个2元组的 <code class="docutils literal notranslate"><span class="pre">(visit,</span> <span class="pre">depart)</span></code> 方法.如果 <code class="docutils literal notranslate"><span class="pre">visit</span></code> 函数引发, <code class="docutils literal notranslate"><span class="pre">depart</span></code> 可以是 <code class="docutils literal notranslate"><span class="pre">None</span></code> <code class="xref py py-exc docutils literal notranslate"><span class="pre">docutils.nodes.SkipNode</span></code> .  例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">math</span><span class="p">(</span><span class="n">docutils</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">def</span> <span class="nf">visit_math_html</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starttag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;math&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">depart_math_html</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;/math&gt;&#39;</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">math</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="p">(</span><span class="n">visit_math_html</span><span class="p">,</span> <span class="n">depart_math_html</span><span class="p">))</span>
</pre></div>
</div>
<p>显然,当您在要翻译的文档中遇到时,您没有指定访问者方法的翻译器会阻塞节点.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 0.5 版更改: </span>添加了对提供访问功能的关键字参数的支持.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_enumerable_node">
<code class="descclassname">Sphinx.</code><code class="descname">add_enumerable_node</code><span class="sig-paren">(</span><em>node</em>, <em>figtype</em>, <em>title_getter=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_enumerable_node"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_enumerable_node" title="永久链接至目标">¶</a></dt>
<dd><p>将Docutils节点类注册为numfig目标.</p>
<p>Sphinx自动为节点编号.然后用户可以使用 <a class="reference internal" href="../usage/restructuredtext/roles.html#role-numref" title="numref role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">numref</span></code></a> 来引用它.</p>
<p><em>figtype</em> is a type of enumerable nodes.  Each figtypes have individual
numbering sequences.  As a system figtypes, <code class="docutils literal notranslate"><span class="pre">figure</span></code>, <code class="docutils literal notranslate"><span class="pre">table</span></code> and
<code class="docutils literal notranslate"><span class="pre">code-block</span></code> are defined.  It is able to add custom nodes to these
default figtypes.  It is also able to define new custom figtype if new
figtype is given.</p>
<p><em>title_getter</em> 是获取节点标题的getter函数.  它需要一个可枚举节点的实例,并且必须将其标题作为字符串返回.  标题用于默认的引用标题 <a class="reference internal" href="../usage/restructuredtext/roles.html#role-ref" title="ref role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">ref</span></code></a>. 默认情况下,Sphinx从节点中搜索 <code class="docutils literal notranslate"><span class="pre">docutils.nodes.caption</span></code> 或 <code class="docutils literal notranslate"><span class="pre">docutils.nodes.title</span></code> 作为标题.</p>
<p>其他关键字参数用于节点访问者功能.有关详细信息,请参阅 <a class="reference internal" href="#sphinx.application.Sphinx.add_node" title="sphinx.application.Sphinx.add_node"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Sphinx.add_node()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_directive">
<code class="descclassname">Sphinx.</code><code class="descname">add_directive</code><span class="sig-paren">(</span><em>name</em>, <em>func</em>, <em>content</em>, <em>arguments</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_directive"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_directive" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descclassname">Sphinx.</code><code class="descname">add_directive</code><span class="sig-paren">(</span><em>name</em>, <em>directiveclass</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_directive"><span class="viewcode-link">[源代码]</span></a></dt>
<dd><p>注册Docutils指令.</p>
<p><em>name</em> 必须是预期的指令名称. 编写指令有两种可能的方法:</p>
<ul class="simple">
<li><p>在docutils 0.4 style中, <em>obj</em> 是指令函数. <em>content</em>, <em>arguments</em> 和 <em>options*被设置为函数的属性,并分别确定该指令是否包含内容,参数和选项.  **此款式已弃用.*</em></p></li>
<li><p>在docutils 0.5 style中, <em>obj</em> 是指令类. 它必须已经具有名为 <em>has_content</em>, <em>required_arguments</em>, <em>optional_arguments</em> , <em>final_argument_whitespace</em> 和 <em>option_spec</em> 的属性,这些属性对应于函数方式的选项.  有关详细信息,请参阅 <a class="reference external" href="http://docutils.sourceforge.net/docs/howto/rst-directives.html">Docutils docs</a>.</p></li>
</ul>
<p>指令类必须从类 <code class="docutils literal notranslate"><span class="pre">docutils.parsers.rst.Directive</span></code> 继承.</p>
<p>例如,(已存在的) <a class="reference internal" href="../usage/restructuredtext/directives.html#directive-literalinclude" title="literalinclude directive"><code class="xref rst rst-dir docutils literal notranslate"><span class="pre">literalinclude</span></code></a> 指令将添加如下:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">docutils.parsers.rst</span> <span class="kn">import</span> <span class="n">Directive</span><span class="p">,</span> <span class="n">directives</span>

<span class="k">class</span> <span class="nc">LiteralIncludeDirective</span><span class="p">(</span><span class="n">Directive</span><span class="p">):</span>
    <span class="n">has_content</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">required_arguments</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">optional_arguments</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final_argument_whitespace</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">option_spec</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="n">directives</span><span class="o">.</span><span class="n">class_option</span><span class="p">,</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">directives</span><span class="o">.</span><span class="n">unchanged</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">add_directive</span><span class="p">(</span><span class="s1">&#39;literalinclude&#39;</span><span class="p">,</span> <span class="n">LiteralIncludeDirective</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 0.6 版更改: </span>现在支持Docutils 0.5样式的指令类.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">1.8 版后已移除: </span>不推荐使用Docutils 0.4-style(基于功能)指令支持.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_role">
<code class="descclassname">Sphinx.</code><code class="descname">add_role</code><span class="sig-paren">(</span><em>name</em>, <em>role</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_role"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_role" title="永久链接至目标">¶</a></dt>
<dd><p>注册Docutils角色.</p>
<p><em>name</em> must be the role name that occurs in the source, <em>role</em> the role
function. Refer to the <a class="reference external" href="http://docutils.sourceforge.net/docs/howto/rst-roles.html">Docutils documentation</a> for
more information.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_generic_role">
<code class="descclassname">Sphinx.</code><code class="descname">add_generic_role</code><span class="sig-paren">(</span><em>name</em>, <em>nodeclass</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_generic_role"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_generic_role" title="永久链接至目标">¶</a></dt>
<dd><p>注册一般的Docutils角色.</p>
<p>注册一个Docutils角色,它只会将其内容包装在 <em>nodeclass</em> 给出的节点中.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.6 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_domain">
<code class="descclassname">Sphinx.</code><code class="descname">add_domain</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_domain"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_domain" title="永久链接至目标">¶</a></dt>
<dd><p>注册域.</p>
<p>使得Sphinx知道给定的 <em>domain</em> (必须是类;更确切地说,是 <a class="reference internal" href="domainapi.html#sphinx.domains.Domain" title="sphinx.domains.Domain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Domain</span></code></a> 的子类).</p>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_directive_to_domain">
<code class="descclassname">Sphinx.</code><code class="descname">add_directive_to_domain</code><span class="sig-paren">(</span><em>domain</em>, <em>name</em>, <em>func</em>, <em>content</em>, <em>arguments</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_directive_to_domain"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_directive_to_domain" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descclassname">Sphinx.</code><code class="descname">add_directive_to_domain</code><span class="sig-paren">(</span><em>domain</em>, <em>name</em>, <em>directiveclass</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_directive_to_domain"><span class="viewcode-link">[源代码]</span></a></dt>
<dd><p>在域中注册Docutils指令.</p>
<p>例如 <a class="reference internal" href="#sphinx.application.Sphinx.add_directive" title="sphinx.application.Sphinx.add_directive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_directive()</span></code></a>, 但该指令被添加到名为 <em>domain</em> 的域中.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_role_to_domain">
<code class="descclassname">Sphinx.</code><code class="descname">add_role_to_domain</code><span class="sig-paren">(</span><em>domain</em>, <em>name</em>, <em>role</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_role_to_domain"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_role_to_domain" title="永久链接至目标">¶</a></dt>
<dd><p>在域中注册Docutils角色.</p>
<p>例如 <a class="reference internal" href="#sphinx.application.Sphinx.add_role" title="sphinx.application.Sphinx.add_role"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_role()</span></code></a>,但角色被添加到名为 <em>domain</em> 的域中.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_index_to_domain">
<code class="descclassname">Sphinx.</code><code class="descname">add_index_to_domain</code><span class="sig-paren">(</span><em>domain</em>, <em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_index_to_domain"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_index_to_domain" title="永久链接至目标">¶</a></dt>
<dd><p>注册域的自定义索引.</p>
<p>将自定义*索引*类添加到名为 <em>domain</em> 的域中. * index <a href="#id1"><span class="problematic" id="id2">*</span></a>必须是 <a class="reference internal" href="domainapi.html#sphinx.domains.Index" title="sphinx.domains.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> 的子类.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_object_type">
<code class="descclassname">Sphinx.</code><code class="descname">add_object_type</code><span class="sig-paren">(</span><em>directivename</em>, <em>rolename</em>, <em>indextemplate=''</em>, <em>parse_node=None</em>, <em>ref_nodeclass=None</em>, <em>objname=''</em>, <em>doc_field_types=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_object_type"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_object_type" title="永久链接至目标">¶</a></dt>
<dd><p>注册新的对象类型.</p>
<p>这个方法是一种非常方便的方法来添加一个新的 <a class="reference internal" href="../glossary.html#term-object"><span class="xref std std-term">object</span></a> 类型,可以交叉引用.它会这样做:</p>
<ul class="simple">
<li><p>Create a new directive (called <em>directivename</em>) for documenting an
object.  It will automatically add index entries if <em>indextemplate</em>
is nonempty; if given, it must contain exactly one instance of
<code class="docutils literal notranslate"><span class="pre">%s</span></code>.  See the example below for how the template will be
interpreted.</p></li>
<li><p>Create a new role (called <em>rolename</em>) to cross-reference to these
object descriptions.</p></li>
<li><p>If you provide <em>parse_node</em>, it must be a function that takes a
string and a docutils node, and it must populate the node with
children parsed from the string.  It must then return the name of the
item to be used in cross-referencing and index entries.  See the
<code class="file docutils literal notranslate"><span class="pre">conf.py</span></code> file in the source for this documentation for an
example.</p></li>
<li><p>The <em>objname</em> (if not given, will default to <em>directivename</em>) names
the type of object.  It is used when listing objects, e.g. in search
results.</p></li>
</ul>
<p>例如,如果您在自定义Sphinx扩展中进行此调用:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>app.add_object_type(&#39;directive&#39;, &#39;dir&#39;, &#39;pair: %s; directive&#39;)
</pre></div>
</div>
<p>您可以在文档中使用此标记:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">rst:directive</span><span class="p">::</span> function

   Document a function.

<span class="nt">&lt;...&gt;</span>

See also the <span class="na">:rst:dir:</span><span class="nv">`function`</span> directive.
</pre></div>
</div>
<p>For the directive, an index entry will be generated as if you had prepended</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">index</span><span class="p">::</span> pair: function; directive
</pre></div>
</div>
<p>The reference node will be of class <code class="docutils literal notranslate"><span class="pre">literal</span></code> (so it will be rendered
in a proportional font, as appropriate for code) unless you give the
<em>ref_nodeclass</em> argument, which must be a docutils node class.  Most
useful are <code class="docutils literal notranslate"><span class="pre">docutils.nodes.emphasis</span></code> or <code class="docutils literal notranslate"><span class="pre">docutils.nodes.strong</span></code> –
you can also use <code class="docutils literal notranslate"><span class="pre">docutils.nodes.generated</span></code> if you want no further
text decoration.  If the text should be treated as literal (e.g. no
smart quote replacement), but not have typewriter styling, use
<code class="docutils literal notranslate"><span class="pre">sphinx.addnodes.literal_emphasis</span></code> or
<code class="docutils literal notranslate"><span class="pre">sphinx.addnodes.literal_strong</span></code>.</p>
<p>For the role content, you have the same syntactical possibilities as
for standard Sphinx roles (see <a class="reference internal" href="../usage/restructuredtext/roles.html#xref-syntax"><span class="std std-ref">交叉引用语法</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_crossref_type">
<code class="descclassname">Sphinx.</code><code class="descname">add_crossref_type</code><span class="sig-paren">(</span><em>directivename</em>, <em>rolename</em>, <em>indextemplate=''</em>, <em>ref_nodeclass=None</em>, <em>objname=''</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_crossref_type"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_crossref_type" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个新的crossref对象类型.</p>
<p>This method is very similar to <a class="reference internal" href="#sphinx.application.Sphinx.add_object_type" title="sphinx.application.Sphinx.add_object_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_object_type()</span></code></a> except that the
directive it generates must be empty, and will produce no output.</p>
<p>That means that you can add semantic targets to your sources, and refer
to them using custom roles instead of generic ones (like
<a class="reference internal" href="../usage/restructuredtext/roles.html#role-ref" title="ref role"><code class="xref rst rst-role docutils literal notranslate"><span class="pre">ref</span></code></a>).  Example call:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>app.add_crossref_type(&#39;topic&#39;, &#39;topic&#39;, &#39;single: %s&#39;,
                      docutils.nodes.emphasis)
</pre></div>
</div>
<p>用法示例:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">topic</span><span class="p">::</span> application API

<span class="gh">The application API</span>
<span class="gh">-------------------</span>

Some random text here.

See also <span class="na">:topic:</span><span class="nv">`this section &lt;application API&gt;`</span>.
</pre></div>
</div>
<p>(Of course, the element following the <code class="docutils literal notranslate"><span class="pre">topic</span></code> directive needn’t be a
section.)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_transform">
<code class="descclassname">Sphinx.</code><code class="descname">add_transform</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_transform"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_transform" title="永久链接至目标">¶</a></dt>
<dd><p>注册解析后要应用的Docutils变换.</p>
<p>Add the standard docutils <code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code> subclass <em>transform</em> to
the list of transforms that are applied after Sphinx parses a reST
document.</p>
<table class="colwidths-given docutils align-center" id="sphinx">
<caption><span class="caption-text">Sphinx变换的优先级范围类别</span><a class="headerlink" href="#sphinx" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>优先</p></td>
<td><p>狮身人面像的主要目的</p></td>
</tr>
<tr class="row-even"><td><p>0-99</p></td>
<td><p>通过docutils修复无效节点.翻译doctree.</p></td>
</tr>
<tr class="row-odd"><td><p>100-299</p></td>
<td><p>制备</p></td>
</tr>
<tr class="row-even"><td><p>300-399</p></td>
<td><p>早</p></td>
</tr>
<tr class="row-odd"><td><p>400-699</p></td>
<td><p>主要</p></td>
</tr>
<tr class="row-even"><td><p>700-799</p></td>
<td><p>后期处理.修改文本和引用的截止日期.</p></td>
</tr>
<tr class="row-odd"><td><p>800-899</p></td>
<td><p>收集引用和引用的节点.域名处理.</p></td>
</tr>
<tr class="row-even"><td><p>900-999</p></td>
<td><p>完成并清理.</p></td>
</tr>
</tbody>
</table>
<p>refs: <a class="reference external" href="http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories">Transform Priority Range Categories</a></p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_post_transform">
<code class="descclassname">Sphinx.</code><code class="descname">add_post_transform</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_post_transform"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_post_transform" title="永久链接至目标">¶</a></dt>
<dd><p>在写入之前注册要应用的Docutils变换.</p>
<p>Add the standard docutils <code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code> subclass <em>transform</em> to
the list of transforms that are applied before Sphinx writes a
document.</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_js_file">
<code class="descclassname">Sphinx.</code><code class="descname">add_js_file</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_js_file"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_js_file" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个JavaScript文件以包含在HTML输出中.</p>
<p>Add <em>filename</em> to the list of JavaScript files that the default HTML
template will include.  The filename must be relative to the HTML
static path , or a full URI with scheme.  The keyword arguments are
also accepted for attributes of <code class="docutils literal notranslate"><span class="pre">&lt;script&gt;</span></code> tag.</p>
<p>例:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>app.add_js_file(&#39;example.js&#39;)
# =&gt; &lt;script src=&quot;_static/example.js&quot;&gt;&lt;/script&gt;

app.add_js_file(&#39;example.js&#39;, async=&quot;async&quot;)
# =&gt; &lt;script src=&quot;_static/example.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>Renamed from <code class="docutils literal notranslate"><span class="pre">app.add_javascript()</span></code>.
And it allows keyword arguments as attributes of script tag.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_css_file">
<code class="descclassname">Sphinx.</code><code class="descname">add_css_file</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_css_file"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_css_file" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个样式表以包含在HTML输出中.</p>
<p>Add <em>filename</em> to the list of CSS files that the default HTML template
will include.  The filename must be relative to the HTML static path,
or a full URI with scheme.  The keyword arguments are also accepted for
attributes of <code class="docutils literal notranslate"><span class="pre">&lt;link&gt;</span></code> tag.</p>
<p>例:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>app.add_css_file(&#39;custom.css&#39;)
# =&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;_static/custom.css&quot; type=&quot;text/css&quot; /&gt;

app.add_css_file(&#39;print.css&#39;, media=&#39;print&#39;)
# =&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;_static/print.css&quot;
#          type=&quot;text/css&quot; media=&quot;print&quot; /&gt;

app.add_css_file(&#39;fancy.css&#39;, rel=&#39;alternate stylesheet&#39;, title=&#39;fancy&#39;)
# =&gt; &lt;link rel=&quot;alternate stylesheet&quot; href=&quot;_static/fancy.css&quot;
#          type=&quot;text/css&quot; title=&quot;fancy&quot; /&gt;
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.6 版更改: </span>Optional <code class="docutils literal notranslate"><span class="pre">alternate</span></code> and/or <code class="docutils literal notranslate"><span class="pre">title</span></code> attributes can be supplied
with the <em>alternate</em> (of boolean type) and <em>title</em> (a string)
arguments. The default is no title and <em>alternate</em> = <code class="docutils literal notranslate"><span class="pre">False</span></code>. For
more information, refer to the <a class="reference external" href="https://mdn.io/Web/CSS/Alternative_style_sheets">documentation</a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>Renamed from <code class="docutils literal notranslate"><span class="pre">app.add_stylesheet()</span></code>.
And it allows keyword arguments as attributes of link tag.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_latex_package">
<code class="descclassname">Sphinx.</code><code class="descname">add_latex_package</code><span class="sig-paren">(</span><em>packagename</em>, <em>options=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_latex_package"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_latex_package" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个包以包含在LaTeX源代码中.</p>
<p>Add <em>packagename</em> to the list of packages that LaTeX source code will
include.  If you provide <em>options</em>, it will be taken to <cite>usepackage</cite>
declaration.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">add_latex_package</span><span class="p">(</span><span class="s1">&#39;mypackage&#39;</span><span class="p">)</span>
<span class="c1"># =&gt; \usepackage{mypackage}</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_latex_package</span><span class="p">(</span><span class="s1">&#39;mypackage&#39;</span><span class="p">,</span> <span class="s1">&#39;foo,bar&#39;</span><span class="p">)</span>
<span class="c1"># =&gt; \usepackage[foo,bar]{mypackage}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">1.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_lexer">
<code class="descclassname">Sphinx.</code><code class="descname">add_lexer</code><span class="sig-paren">(</span><em>alias</em>, <em>lexer</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_lexer"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_lexer" title="永久链接至目标">¶</a></dt>
<dd><p>为源代码注册一个新词法分析器.</p>
<p>Use <em>lexer</em>, which must be an instance of a Pygments lexer class, to
highlight code blocks with the given language <em>alias</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_autodocumenter">
<code class="descclassname">Sphinx.</code><code class="descname">add_autodocumenter</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_autodocumenter"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_autodocumenter" title="永久链接至目标">¶</a></dt>
<dd><p>注册autodoc扩展的新文档类.</p>
<p>Add <em>cls</em> as a new documenter class for the <a class="reference internal" href="../usage/extensions/autodoc.html#module-sphinx.ext.autodoc" title="sphinx.ext.autodoc: Include documentation from docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sphinx.ext.autodoc</span></code></a>
extension.  It must be a subclass of
<code class="xref py py-class docutils literal notranslate"><span class="pre">sphinx.ext.autodoc.Documenter</span></code>.  This allows to auto-document
new types of objects.  See the source of the autodoc module for
examples on how to subclass <code class="xref py py-class docutils literal notranslate"><span class="pre">Documenter</span></code>.</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">待处理</p>
<p>为Documenter和子类化添加真正的文档</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">0.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_autodoc_attrgetter">
<code class="descclassname">Sphinx.</code><code class="descname">add_autodoc_attrgetter</code><span class="sig-paren">(</span><em>type</em>, <em>getter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_autodoc_attrgetter"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_autodoc_attrgetter" title="永久链接至目标">¶</a></dt>
<dd><p>为autodoc扩展注册一个新的``getattr``函数.</p>
<p>Add <em>getter</em>, which must be a function with an interface compatible to
the <code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code> builtin, as the autodoc attribute getter for
objects that are instances of <em>typ</em>.  All cases where autodoc needs to
get an attribute of a type are then handled by this function instead of
<code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_search_language">
<code class="descclassname">Sphinx.</code><code class="descname">add_search_language</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_search_language"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_search_language" title="永久链接至目标">¶</a></dt>
<dd><p>为HTML搜索索引注册新语言.</p>
<p>Add <em>cls</em>, which must be a subclass of
<code class="xref py py-class docutils literal notranslate"><span class="pre">sphinx.search.SearchLanguage</span></code>, as a support language for
building the HTML full-text search index.  The class must have a <em>lang</em>
attribute that indicates the language it should be used for.  See
<a class="reference internal" href="../usage/configuration.html#confval-html_search_language"><code class="xref std std-confval docutils literal notranslate"><span class="pre">html_search_language</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_source_suffix">
<code class="descclassname">Sphinx.</code><code class="descname">add_source_suffix</code><span class="sig-paren">(</span><em>suffix</em>, <em>filetype</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_source_suffix"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_source_suffix" title="永久链接至目标">¶</a></dt>
<dd><p>注册源文件的后缀.</p>
<p>Same as <a class="reference internal" href="../usage/configuration.html#confval-source_suffix"><code class="xref std std-confval docutils literal notranslate"><span class="pre">source_suffix</span></code></a>.  The users can override this
using the setting.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_source_parser">
<code class="descclassname">Sphinx.</code><code class="descname">add_source_parser</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_source_parser"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_source_parser" title="永久链接至目标">¶</a></dt>
<dd><p>注册解析器类.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span><em>suffix</em> argument is deprecated.  It only accepts <em>parser</em> argument.
Use <a class="reference internal" href="#sphinx.application.Sphinx.add_source_suffix" title="sphinx.application.Sphinx.add_source_suffix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_source_suffix()</span></code></a> API to register suffix instead.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.8 版更改: </span>添加 <em>override</em> 关键字.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_env_collector">
<code class="descclassname">Sphinx.</code><code class="descname">add_env_collector</code><span class="sig-paren">(</span><em>collector</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_env_collector"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_env_collector" title="永久链接至目标">¶</a></dt>
<dd><p>注册环境收集器类.</p>
<p>参考 <a class="reference internal" href="collectorapi.html#collector-api"><span class="std std-ref">环境收集器API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_html_theme">
<code class="descclassname">Sphinx.</code><code class="descname">add_html_theme</code><span class="sig-paren">(</span><em>name</em>, <em>theme_path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_html_theme"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_html_theme" title="永久链接至目标">¶</a></dt>
<dd><p>注册HTML主题.</p>
<p>The <em>name</em> is a name of theme, and <em>path</em> is a full path to the theme
(refs: <a class="reference internal" href="../theming.html#distribute-your-theme"><span class="std std-ref">将您的主题分发为Python包</span></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">1.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_html_math_renderer">
<code class="descclassname">Sphinx.</code><code class="descname">add_html_math_renderer</code><span class="sig-paren">(</span><em>name</em>, <em>inline_renderers</em>, <em>block_renderers</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_html_math_renderer"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_html_math_renderer" title="永久链接至目标">¶</a></dt>
<dd><p>注册HTML的数学渲染器.</p>
<p>The <em>name</em> is a name of math renderer.  Both <em>inline_renderers</em> and
<em>block_renderers</em> are used as visitor functions for the HTML writer:
the former for inline math node (<code class="docutils literal notranslate"><span class="pre">nodes.math</span></code>), the latter for
block math node (<code class="docutils literal notranslate"><span class="pre">nodes.math_block</span></code>).  Regarding visitor functions,
see <a class="reference internal" href="#sphinx.application.Sphinx.add_node" title="sphinx.application.Sphinx.add_node"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_node()</span></code></a> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.add_message_catalog">
<code class="descclassname">Sphinx.</code><code class="descname">add_message_catalog</code><span class="sig-paren">(</span><em>catalog</em>, <em>locale_dir</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.add_message_catalog"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.add_message_catalog" title="永久链接至目标">¶</a></dt>
<dd><p>注册消息目录.</p>
<p>The <em>catalog</em> is a name of catalog, and <em>locale_dir</em> is a base path
of message catalog.  For more details, see
<a class="reference internal" href="i18n.html#sphinx.locale.get_translation" title="sphinx.locale.get_translation"><code class="xref py py-func docutils literal notranslate"><span class="pre">sphinx.locale.get_translation()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.is_parallel_allowed">
<code class="descclassname">Sphinx.</code><code class="descname">is_parallel_allowed</code><span class="sig-paren">(</span><em>typ</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.is_parallel_allowed"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.is_parallel_allowed" title="永久链接至目标">¶</a></dt>
<dd><p>是否允许检查并行处理.</p>
<p><code class="docutils literal notranslate"><span class="pre">typ</span></code> is a type of processing; <code class="docutils literal notranslate"><span class="pre">'read'</span></code> or <code class="docutils literal notranslate"><span class="pre">'write'</span></code>.</p>
</dd></dl>

<dl class="exception">
<dt id="sphinx.application.ExtensionError">
<em class="property">exception </em><code class="descclassname">sphinx.application.</code><code class="descname">ExtensionError</code><a class="headerlink" href="#sphinx.application.ExtensionError" title="永久链接至目标">¶</a></dt>
<dd><p>如果扩展API出现问题，所有这些方法都会引发此异常。</p>
</dd></dl>

</div>
<div class="section" id="emitting-events">
<h2>发出事件<a class="headerlink" href="#emitting-events" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">sphinx.application.</code><code class="descname">Sphinx</code><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx"><span class="viewcode-link">[源代码]</span></a></dt>
<dd><dl class="method">
<dt id="sphinx.application.Sphinx.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>event</em>, <em>*arguments</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.emit"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.emit" title="永久链接至目标">¶</a></dt>
<dd><p>Emit <em>event</em> 并将 <em>arguments</em> 传递给回调函数.</p>
<p>将所有回调的返回值作为列表返回。不要在扩展中发出核心Sphinx事件！</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.Sphinx.emit_firstresult">
<code class="descname">emit_firstresult</code><span class="sig-paren">(</span><em>event</em>, <em>*arguments</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#Sphinx.emit_firstresult"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.Sphinx.emit_firstresult" title="永久链接至目标">¶</a></dt>
<dd><p>Emit <em>event</em> 并将 <em>arguments</em> 传递给回调函数.</p>
<p>返回不返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的第一个回调的结果.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sphinx-runtime-information">
<h2>Sphinx运行时信息<a class="headerlink" href="#sphinx-runtime-information" title="永久链接至标题">¶</a></h2>
<p>应用程序对象还提供运行时信息作为属性.</p>
<dl class="attribute">
<dt id="sphinx.application.Sphinx.project">
<code class="descclassname">Sphinx.</code><code class="descname">project</code><a class="headerlink" href="#sphinx.application.Sphinx.project" title="永久链接至目标">¶</a></dt>
<dd><p>目标项目.见 <a class="reference internal" href="projectapi.html#sphinx.project.Project" title="sphinx.project.Project"><code class="xref py py-class docutils literal notranslate"><span class="pre">Project</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="sphinx.application.Sphinx.srcdir">
<code class="descclassname">Sphinx.</code><code class="descname">srcdir</code><a class="headerlink" href="#sphinx.application.Sphinx.srcdir" title="永久链接至目标">¶</a></dt>
<dd><p>源目录.</p>
</dd></dl>

<dl class="attribute">
<dt id="sphinx.application.Sphinx.confdir">
<code class="descclassname">Sphinx.</code><code class="descname">confdir</code><a class="headerlink" href="#sphinx.application.Sphinx.confdir" title="永久链接至目标">¶</a></dt>
<dd><p>包含 <code class="docutils literal notranslate"><span class="pre">conf.py</span></code> 的目录.</p>
</dd></dl>

<dl class="attribute">
<dt id="sphinx.application.Sphinx.doctreedir">
<code class="descclassname">Sphinx.</code><code class="descname">doctreedir</code><a class="headerlink" href="#sphinx.application.Sphinx.doctreedir" title="永久链接至目标">¶</a></dt>
<dd><p>存储酸洗doctree的目录.</p>
</dd></dl>

<dl class="attribute">
<dt id="sphinx.application.Sphinx.outdir">
<code class="descclassname">Sphinx.</code><code class="descname">outdir</code><a class="headerlink" href="#sphinx.application.Sphinx.outdir" title="永久链接至目标">¶</a></dt>
<dd><p>用于存储构建文档的目录.</p>
</dd></dl>

</div>
<div class="section" id="sphinx-core-events">
<span id="events"></span><h2>狮身人面像核心事件<a class="headerlink" href="#sphinx-core-events" title="永久链接至标题">¶</a></h2>
<p>These events are known to the core.  The arguments shown are given to the
registered event handlers.  Use <a class="reference internal" href="#sphinx.application.Sphinx.connect" title="sphinx.application.Sphinx.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Sphinx.connect()</span></code></a> in an extension’s <code class="docutils literal notranslate"><span class="pre">setup</span></code>
function (note that <code class="docutils literal notranslate"><span class="pre">conf.py</span></code> can also have a <code class="docutils literal notranslate"><span class="pre">setup</span></code> function) to connect
handlers to the events.  Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">source_read_handler</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">docname</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;do something here...&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;source-read&#39;</span><span class="p">,</span> <span class="n">source_read_handler</span><span class="p">)</span>
</pre></div>
</div>
<dl class="event">
<dt id="event-builder-inited">
<code class="descname">builder-inited</code><span class="sig-paren">(</span><em>app</em><span class="sig-paren">)</span><a class="headerlink" href="#event-builder-inited" title="永久链接至目标">¶</a></dt>
<dd><p>创建构建器对象时发出。 它可以作为 <code class="docutils literal notranslate"><span class="pre">app.builder</span></code>.</p>
</dd></dl>

<dl class="event">
<dt id="event-config-inited">
<code class="descname">config-inited</code><span class="sig-paren">(</span><em>app</em>, <em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#event-config-inited" title="永久链接至目标">¶</a></dt>
<dd><p>初始化配置对象时发出.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-env-get-outdated">
<code class="descname">env-get-outdated</code><span class="sig-paren">(</span><em>app</em>, <em>env</em>, <em>added</em>, <em>changed</em>, <em>removed</em><span class="sig-paren">)</span><a class="headerlink" href="#event-env-get-outdated" title="永久链接至目标">¶</a></dt>
<dd><p>当环境确定哪些源文件已更改并应重新读取时发出。 <em>added</em>, <em>changed</em> 和 <em>removed</em> 是环境已确定的文档名集。除了这些之外，您还可以返回要重新阅读的文档名列表。</p>
<div class="versionadded">
<p><span class="versionmodified added">1.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-env-purge-doc">
<code class="descname">env-purge-doc</code><span class="sig-paren">(</span><em>app</em>, <em>env</em>, <em>docname</em><span class="sig-paren">)</span><a class="headerlink" href="#event-env-purge-doc" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when all traces of a source file should be cleaned from the
environment, that is, if the source file is removed or before it is freshly
read.  This is for extensions that keep their own caches in attributes of the
environment.</p>
<p>For example, there is a cache of all modules on the environment.  When a
source file has been changed, the cache’s entries for the file are cleared,
since the module declarations could have been removed from the file.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-env-before-read-docs">
<code class="descname">env-before-read-docs</code><span class="sig-paren">(</span><em>app</em>, <em>env</em>, <em>docnames</em><span class="sig-paren">)</span><a class="headerlink" href="#event-env-before-read-docs" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted after the environment has determined the list of all added and
changed files and just before it reads them.  It allows extension authors to
reorder the list of docnames (<em>inplace</em>) before processing, or add more
docnames that Sphinx did not consider changed (but never add any docnames
that are not in <code class="docutils literal notranslate"><span class="pre">env.found_docs</span></code>).</p>
<p>You can also remove document names; do this with caution since it will make
Sphinx treat changed files as unchanged.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-source-read">
<code class="descname">source-read</code><span class="sig-paren">(</span><em>app</em>, <em>docname</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#event-source-read" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when a source file has been read.  The <em>source</em> argument is a list
whose single element is the contents of the source file.  You can process the
contents and replace this item to implement source-level transformations.</p>
<p>For example, if you want to use <code class="docutils literal notranslate"><span class="pre">$</span></code> signs to delimit inline math, like in
LaTeX, you can use a regular expression to replace <code class="docutils literal notranslate"><span class="pre">$...$</span></code> by
<code class="docutils literal notranslate"><span class="pre">:math:`...`</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-doctree-read">
<code class="descname">doctree-read</code><span class="sig-paren">(</span><em>app</em>, <em>doctree</em><span class="sig-paren">)</span><a class="headerlink" href="#event-doctree-read" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when a doctree has been parsed and read by the environment, and is
about to be pickled.  The <em>doctree</em> can be modified in-place.</p>
</dd></dl>

<dl class="event">
<dt id="event-missing-reference">
<code class="descname">missing-reference</code><span class="sig-paren">(</span><em>app</em>, <em>env</em>, <em>node</em>, <em>contnode</em><span class="sig-paren">)</span><a class="headerlink" href="#event-missing-reference" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when a cross-reference to a Python module or object cannot be
resolved.  If the event handler can resolve the reference, it should return a
new docutils node to be inserted in the document tree in place of the node
<em>node</em>.  Usually this node is a <code class="xref py py-class docutils literal notranslate"><span class="pre">reference</span></code> node containing <em>contnode</em>
as a child.</p>
<dl class="field-list simple">
<dt class="field-odd">参数</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>env</strong> – The build environment (<code class="docutils literal notranslate"><span class="pre">app.builder.env</span></code>).</p></li>
<li><p><strong>node</strong> – The <code class="xref py py-class docutils literal notranslate"><span class="pre">pending_xref</span></code> node to be resolved.  Its attributes
<code class="docutils literal notranslate"><span class="pre">reftype</span></code>, <code class="docutils literal notranslate"><span class="pre">reftarget</span></code>, <code class="docutils literal notranslate"><span class="pre">modname</span></code> and <code class="docutils literal notranslate"><span class="pre">classname</span></code> attributes
determine the type and target of the reference.</p></li>
<li><p><strong>contnode</strong> – The node that carries the text and formatting inside the
future reference and should be a child of the returned reference node.</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-doctree-resolved">
<code class="descname">doctree-resolved</code><span class="sig-paren">(</span><em>app</em>, <em>doctree</em>, <em>docname</em><span class="sig-paren">)</span><a class="headerlink" href="#event-doctree-resolved" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when a doctree has been “resolved” by the environment, that is, all
references have been resolved and TOCs have been inserted.  The <em>doctree</em> can
be modified in place.</p>
<p>Here is the place to replace custom nodes that don’t have visitor methods in
the writers, so that they don’t cause errors when the writers encounter them.</p>
</dd></dl>

<dl class="event">
<dt id="event-env-merge-info">
<code class="descname">env-merge-info</code><span class="sig-paren">(</span><em>app</em>, <em>env</em>, <em>docnames</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#event-env-merge-info" title="永久链接至目标">¶</a></dt>
<dd><p>This event is only emitted when parallel reading of documents is enabled.  It
is emitted once for every subprocess that has read some documents.</p>
<p>You must handle this event in an extension that stores data in the
environment in a custom location.  Otherwise the environment in the main
process will not be aware of the information stored in the subprocess.</p>
<p><em>other</em> is the environment object from the subprocess, <em>env</em> is the
environment from the main process.  <em>docnames</em> is a set of document names
that have been read in the subprocess.</p>
<p>For a sample of how to deal with this event, look at the standard
<code class="docutils literal notranslate"><span class="pre">sphinx.ext.todo</span></code> extension.  The implementation is often similar to that
of <a class="reference internal" href="#event-env-purge-doc"><code class="xref std std-event docutils literal notranslate"><span class="pre">env-purge-doc</span></code></a>, only that information is not removed, but added to
the main environment from the other environment.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-env-updated">
<code class="descname">env-updated</code><span class="sig-paren">(</span><em>app</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#event-env-updated" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when the <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> method of the build environment has
completed, that is, the environment and all doctrees are now up-to-date.</p>
<p>You can return an iterable of docnames from the handler.  These documents
will then be considered updated, and will be (re-)written during the writing
phase.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.3 版更改: </span>The handlers’ return value is now used.</p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-env-check-consistency">
<code class="descname">env-check-consistency</code><span class="sig-paren">(</span><em>app</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#event-env-check-consistency" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when Consistency checks phase.  You can check consistency of
metadata for whole of documents.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.6 新版功能: </span>作为**实验**事件</p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-html-collect-pages">
<code class="descname">html-collect-pages</code><span class="sig-paren">(</span><em>app</em><span class="sig-paren">)</span><a class="headerlink" href="#event-html-collect-pages" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when the HTML builder is starting to write non-document pages.  You
can add pages to write by returning an iterable from this event consisting of
<code class="docutils literal notranslate"><span class="pre">(pagename,</span> <span class="pre">context,</span> <span class="pre">templatename)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.0 新版功能.</span></p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-html-page-context">
<code class="descname">html-page-context</code><span class="sig-paren">(</span><em>app</em>, <em>pagename</em>, <em>templatename</em>, <em>context</em>, <em>doctree</em><span class="sig-paren">)</span><a class="headerlink" href="#event-html-page-context" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when the HTML builder has created a context dictionary to render a
template with – this can be used to add custom elements to the context.</p>
<p>The <em>pagename</em> argument is the canonical name of the page being rendered,
that is, without <code class="docutils literal notranslate"><span class="pre">.html</span></code> suffix and using slashes as path separators.  The
<em>templatename</em> is the name of the template to render, this will be
<code class="docutils literal notranslate"><span class="pre">'page.html'</span></code> for all pages from reST documents.</p>
<p>The <em>context</em> argument is a dictionary of values that are given to the
template engine to render the page and can be modified to include custom
values.  Keys must be strings.</p>
<p>The <em>doctree</em> argument will be a doctree when the page is created from a reST
documents; it will be <code class="docutils literal notranslate"><span class="pre">None</span></code> when the page is created from an HTML template
alone.</p>
<p>You can return a string from the handler, it will then replace
<code class="docutils literal notranslate"><span class="pre">'page.html'</span></code> as the HTML template for this page.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 1.3 版更改: </span>返回值现在可以指定模板名称.</p>
</div>
</dd></dl>

<dl class="event">
<dt id="event-build-finished">
<code class="descname">build-finished</code><span class="sig-paren">(</span><em>app</em>, <em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#event-build-finished" title="永久链接至目标">¶</a></dt>
<dd><p>Emitted when a build has finished, before Sphinx exits, usually used for
cleanup.  This event is emitted even when the build process raised an
exception, given as the <em>exception</em> argument.  The exception is reraised in
the application after the event handlers have run.  If the build process
raised no exception, <em>exception</em> will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.  This allows to customize
cleanup actions depending on the exception status.</p>
<div class="versionadded">
<p><span class="versionmodified added">0.5 新版功能.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="checking-the-sphinx-version">
<h2>检查Sphinx版本<a class="headerlink" href="#checking-the-sphinx-version" title="永久链接至标题">¶</a></h2>
<p>使用此选项可以使您的扩展适应Sphinx中的API更改.</p>
<dl class="data">
<dt id="sphinx.version_info">
<code class="descclassname">sphinx.</code><code class="descname">version_info</code><em class="property"> = (2, 1, 0, 'beta', 0)</em><a class="headerlink" href="#sphinx.version_info" title="永久链接至目标">¶</a></dt>
<dd><p>版本信息,以便更好地使用程序.</p>
<p>A tuple of five elements; for Sphinx version 1.2.1 beta 3 this would be
<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">'beta',</span> <span class="pre">3)</span></code>. The fourth element can be one of: <code class="docutils literal notranslate"><span class="pre">alpha</span></code>,
<code class="docutils literal notranslate"><span class="pre">beta</span></code>, <code class="docutils literal notranslate"><span class="pre">rc</span></code>, <code class="docutils literal notranslate"><span class="pre">final</span></code>. <code class="docutils literal notranslate"><span class="pre">final</span></code> always has 0 as the last element.</p>
<div class="versionadded">
<p><span class="versionmodified added">1.2 新版功能: </span>在1.2版之前,检查字符串``sphinx .__ version__``.</p>
</div>
</dd></dl>

</div>
<div class="section" id="the-config-object">
<h2>Config对象<a class="headerlink" href="#the-config-object" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="sphinx.config.Config">
<em class="property">class </em><code class="descclassname">sphinx.config.</code><code class="descname">Config</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/config.html#Config"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.config.Config" title="永久链接至目标">¶</a></dt>
<dd><p>配置文件抽象.</p>
<p>The config object makes the values of all config values available as
attributes.</p>
<p>It is exposed via the <code class="xref py py-attr docutils literal notranslate"><span class="pre">sphinx.application.Application.config</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sphinx.environment.Environment.config</span></code> attributes. For example,
to get the value of <a class="reference internal" href="../usage/configuration.html#confval-language"><code class="xref std std-confval docutils literal notranslate"><span class="pre">language</span></code></a>, use either <code class="docutils literal notranslate"><span class="pre">app.config.language</span></code>
or <code class="docutils literal notranslate"><span class="pre">env.config.language</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="the-template-bridge">
<span id="template-bridge"></span><h2>模板桥<a class="headerlink" href="#the-template-bridge" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="sphinx.application.TemplateBridge">
<em class="property">class </em><code class="descclassname">sphinx.application.</code><code class="descname">TemplateBridge</code><a class="reference internal" href="../_modules/sphinx/application.html#TemplateBridge"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.TemplateBridge" title="永久链接至目标">¶</a></dt>
<dd><p>This class defines the interface for a “template bridge”, that is, a class
that renders templates given a template name and a context.</p>
<dl class="method">
<dt id="sphinx.application.TemplateBridge.init">
<code class="descname">init</code><span class="sig-paren">(</span><em>builder</em>, <em>theme=None</em>, <em>dirs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#TemplateBridge.init"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.TemplateBridge.init" title="永久链接至目标">¶</a></dt>
<dd><p>由构建器调用以初始化模板系统.</p>
<p><em>builder</em> is the builder object; you’ll probably want to look at the
value of <code class="docutils literal notranslate"><span class="pre">builder.config.templates_path</span></code>.</p>
<p><em>theme</em> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">sphinx.theming.Theme</span></code> object or None; in the latter
case, <em>dirs</em> can be list of fixed directories to look for templates.</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.TemplateBridge.newest_template_mtime">
<code class="descname">newest_template_mtime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#TemplateBridge.newest_template_mtime"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.TemplateBridge.newest_template_mtime" title="永久链接至目标">¶</a></dt>
<dd><p>Called by the builder to determine if output files are outdated
because of template changes.  Return the mtime of the newest template
file that was changed.  The default implementation returns <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.TemplateBridge.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>template</em>, <em>context</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#TemplateBridge.render"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.TemplateBridge.render" title="永久链接至目标">¶</a></dt>
<dd><p>Called by the builder to render a template given as a filename with
a specified context (a Python dictionary).</p>
</dd></dl>

<dl class="method">
<dt id="sphinx.application.TemplateBridge.render_string">
<code class="descname">render_string</code><span class="sig-paren">(</span><em>template</em>, <em>context</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/application.html#TemplateBridge.render_string"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.application.TemplateBridge.render_string" title="永久链接至目标">¶</a></dt>
<dd><p>Called by the builder to render a template given as a string with a
specified context (a Python dictionary).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions">
<span id="id3"></span><h2>例外<a class="headerlink" href="#exceptions" title="永久链接至标题">¶</a></h2>
<span class="target" id="module-sphinx.errors"></span><dl class="exception">
<dt id="sphinx.errors.SphinxError">
<em class="property">exception </em><code class="descclassname">sphinx.errors.</code><code class="descname">SphinxError</code><a class="reference internal" href="../_modules/sphinx/errors.html#SphinxError"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.errors.SphinxError" title="永久链接至目标">¶</a></dt>
<dd><p>Sphinx错误的基类.</p>
<p>This is the base class for “nice” exceptions.  When such an exception is
raised, Sphinx will abort the build and present the exception category and
message to the user.</p>
<p>Extensions are encouraged to derive from this exception for their custom
errors.</p>
<p>Exceptions <em>not</em> derived from <a class="reference internal" href="#sphinx.errors.SphinxError" title="sphinx.errors.SphinxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SphinxError</span></code></a> are treated as unexpected
and shown to the user with a part of the traceback (and the full traceback
saved in a temporary file).</p>
<dl class="attribute">
<dt id="sphinx.errors.SphinxError.category">
<code class="descname">category</code><a class="headerlink" href="#sphinx.errors.SphinxError.category" title="永久链接至目标">¶</a></dt>
<dd><p>Description of the exception “category”, used in converting the
exception to a string (“category: message”).  Should be set accordingly
in subclasses.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="sphinx.errors.ConfigError">
<em class="property">exception </em><code class="descclassname">sphinx.errors.</code><code class="descname">ConfigError</code><a class="reference internal" href="../_modules/sphinx/errors.html#ConfigError"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.errors.ConfigError" title="永久链接至目标">¶</a></dt>
<dd><p>配置错误.</p>
</dd></dl>

<dl class="exception">
<dt id="sphinx.errors.ExtensionError">
<em class="property">exception </em><code class="descclassname">sphinx.errors.</code><code class="descname">ExtensionError</code><span class="sig-paren">(</span><em>message</em>, <em>orig_exc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sphinx/errors.html#ExtensionError"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.errors.ExtensionError" title="永久链接至目标">¶</a></dt>
<dd><p>扩展错误.</p>
</dd></dl>

<dl class="exception">
<dt id="sphinx.errors.ThemeError">
<em class="property">exception </em><code class="descclassname">sphinx.errors.</code><code class="descname">ThemeError</code><a class="reference internal" href="../_modules/sphinx/errors.html#ThemeError"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.errors.ThemeError" title="永久链接至目标">¶</a></dt>
<dd><p>主题错误.</p>
</dd></dl>

<dl class="exception">
<dt id="sphinx.errors.VersionRequirementError">
<em class="property">exception </em><code class="descclassname">sphinx.errors.</code><code class="descname">VersionRequirementError</code><a class="reference internal" href="../_modules/sphinx/errors.html#VersionRequirementError"><span class="viewcode-link">[源代码]</span></a><a class="headerlink" href="#sphinx.errors.VersionRequirementError" title="永久链接至目标">¶</a></dt>
<dd><p>不兼容的Sphinx版本错误.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../http-routingtable.html" title="HTTP Routing Table"
             >routing table</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="projectapi.html" title="项目API"
             >下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="开发扩展"
             >上一页</a> |</li>
<li><a href="../index.html">主页</a>&#160;|</li>
<li><a href="../contents.html">文档</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >开发扩展</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2007-2019, Georg Brandl and the Sphinx team.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.0+/e678b9c34 创建。
    </div>
  </body>
</html>