# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2019, Georg Brandl and the Sphinx team
# This file is distributed under the same license as the Sphinx package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx 2.1.0+/1499a97c2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-29 17:17+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../extdev/markupapi.rst:2
msgid "Docutils markup API"
msgstr "Docutils标记API"

#: ../../extdev/markupapi.rst:4
msgid ""
"This section describes the API for adding ReST markup elements (roles and"
" directives)."
msgstr "本节介绍用于添加ReST标记元素(角色和指令)的API."

#: ../../extdev/markupapi.rst:8
msgid "Roles"
msgstr "角色"

#: ../../extdev/markupapi.rst:12
msgid "Directives"
msgstr "指令"

#: ../../extdev/markupapi.rst:14
msgid ""
"Directives are handled by classes derived from "
"``docutils.parsers.rst.Directive``.  They have to be registered by an "
"extension using :meth:`.Sphinx.add_directive` or "
":meth:`.Sphinx.add_directive_to_domain`."
msgstr "指令由派生自 ``docutils.parsers.rst.Directive`` 的类处理.它们必须使用以下命令通过扩展名注册 :meth:`.Sphinx.add_directive` 或 :meth:`.Sphinx.add_directive_to_domain`. "

#: ../../extdev/markupapi.rst:22
msgid ""
"The markup syntax of the new directive is determined by the follow five "
"class attributes:"
msgstr "新指令的标记语法由以下五个类属性决定:"

#: docutils.parsers.rst.Directive.required_arguments:1 of
msgid "Number of required directive arguments."
msgstr "必需的指令参数数量."

#: docutils.parsers.rst.Directive.optional_arguments:1 of
msgid "Number of optional arguments after the required arguments."
msgstr "必需参数后的可选参数数."

#: docutils.parsers.rst.Directive.final_argument_whitespace:1 of
msgid "May the final argument contain whitespace?"
msgstr "可能最后一个参数包含空格吗？"

#: docutils.parsers.rst.Directive.option_spec:1 of
msgid "Mapping of option names to validator functions."
msgstr "将选项名称映射到验证器函数."

#: ../../extdev/markupapi.rst:30
msgid ""
"Option validator functions take a single parameter, the option argument "
"(or ``None`` if not given), and should validate it or convert it to the "
"proper form.  They raise :exc:`ValueError` or :exc:`TypeError` to "
"indicate failure."
msgstr "选项验证器函数采用单个参数, 即选项参数(如果没有给出, 则为 ``None``), 并应验证它或将其转换为正确的形式.他们提出 :exc:`ValueError` 或 :exc:`TypeError` 表示失败."

#: ../../extdev/markupapi.rst:35
msgid ""
"There are several predefined and possibly useful validators in the "
":mod:`docutils.parsers.rst.directives` module."
msgstr "在 :mod:`docutils.parsers.rst.directives` 模块中有几个预定义且可能有用的验证器."

#: docutils.parsers.rst.Directive.has_content:1 of
msgid "May the directive have content?"
msgstr "该指令可能有内容吗？"

#: ../../extdev/markupapi.rst:40
msgid "New directives must implement the :meth:`run` method:"
msgstr "新指令必须实现 :meth:`run` 方法:"

#: ../../extdev/markupapi.rst:44
msgid ""
"This method must process the directive arguments, options and content, "
"and return a list of Docutils/Sphinx nodes that will be inserted into the"
" document tree at the point where the directive was encountered."
msgstr "此方法必须处理指令参数, 选项和内容, 并返回将在遇到指令时插入到文档树中的 Docutils/Sphinx 节点列表."

#: ../../extdev/markupapi.rst:48
msgid "Instance attributes that are always set on the directive are:"
msgstr "始终在指令上设置的实例属性是:"

#: ../../extdev/markupapi.rst:52
msgid ""
"The directive name (useful when registering the same directive class "
"under multiple names)."
msgstr "指令名称(在多个名称下注册相同的指令类时很有用)."

#: ../../extdev/markupapi.rst:57
msgid "The arguments given to the directive, as a list."
msgstr "作为列表给出指令的参数."

#: ../../extdev/markupapi.rst:61
msgid ""
"The options given to the directive, as a dictionary mapping option names "
"to validated/converted values."
msgstr "赋予指令的选项, 作为字典映射选项命名为验证/转换值."

#: ../../extdev/markupapi.rst:66
msgid "The directive content, if given, as a :class:`.ViewList`."
msgstr "指令内容, 如果给出, 则作为 :class:`.ViewList`."

#: ../../extdev/markupapi.rst:70
msgid ""
"The absolute line number on which the directive appeared.  This is not "
"always a useful value; use :attr:`srcline` instead."
msgstr "指令出现的绝对行号.这并不总是有用的价值;使用 :attr:`srcline` 代替."

#: ../../extdev/markupapi.rst:75
msgid ""
"Internal offset of the directive content.  Used when calling "
"``nested_parse`` (see below)."
msgstr "指令内容的内部偏移量.在调用 ``nested_pa​​rse`` 时使用(见下文)."

#: ../../extdev/markupapi.rst:80
msgid "The string containing the entire directive."
msgstr "包含整个指令的字符串."

#: ../../extdev/markupapi.rst:85
msgid ""
"The state and state machine which controls the parsing.  Used for "
"``nested_parse``."
msgstr "控制解析的状态和状态机.用于 ``nested_pa​​rse``."

#: ../../extdev/markupapi.rst:90
msgid "ViewLists"
msgstr "查看列表"

#: ../../extdev/markupapi.rst:92
msgid ""
"Docutils represents document source lines in a class "
"``docutils.statemachine.ViewList``.  This is a list with extended "
"functionality -- for one, slicing creates views of the original list, and"
" also the list contains information about the source line numbers."
msgstr "Docutils在类 ``docutils.statemachine.ViewList`` 中表示文档源代码行.  这是一个具有扩展功能的列表 - 例如, 切片创建原始列表的视图, 并且列表还包含有关源行号的信息."

#: ../../extdev/markupapi.rst:97
msgid ""
"The :attr:`Directive.content` attribute is a ViewList.  If you generate "
"content to be parsed as ReST, you have to create a ViewList yourself.  "
"Important for content generation are the following points:"
msgstr ":attr:`Directive.content` 属性是一个ViewList.  如果生成要解析为ReST的内容, 则必须自己创建ViewList. 内容生成的重要性有以下几点:"

#: ../../extdev/markupapi.rst:101
msgid ""
"The constructor takes a list of strings (lines) and a source (document) "
"name."
msgstr "构造函数获取字符串(行)和源(文档)名称的列表."

#: ../../extdev/markupapi.rst:103
msgid "The ``.append()`` method takes a line and a source name as well."
msgstr "``.append()`` 方法也接受一行和一个源名称."

#: ../../extdev/markupapi.rst:107
msgid "Parsing directive content as ReST"
msgstr "将指令内容解析为ReST"

#: ../../extdev/markupapi.rst:109
msgid ""
"Many directives will contain more markup that must be parsed.  To do "
"this, use one of the following APIs from the :meth:`Directive.run` "
"method:"
msgstr "许多指令将包含必须解析的更多标记. 为此, 请使用以下API中的一个 :meth:`Directive.run` 方法:"

#: ../../extdev/markupapi.rst:112
msgid "``self.state.nested_parse``"
msgstr "``self.state.nested_parse``"

#: ../../extdev/markupapi.rst:113
msgid ""
":func:`sphinx.util.nodes.nested_parse_with_titles` -- this allows titles "
"in the parsed content."
msgstr ":func:`sphinx.util.nodes.nested_pa​​rse_with_titles`  - 这允许解析内容中的标题."

#: ../../extdev/markupapi.rst:116
msgid "Both APIs parse the content into a given node. They are used like this::"
msgstr "两个API都将内容解析为给定节点.它们像这样使用::"

#: ../../extdev/markupapi.rst:126
msgid ""
"``sphinx.util.docutils.switch_source_input()`` allows to change a target "
"file during nested_parse.  It is useful to mixed contents.  For example, "
"``sphinx. ext.autodoc`` uses it to parse docstrings::"
msgstr "``sphinx.util.docutils.switch_source_input()`` 允许在nested_pa​​rse期间更改目标文件.混合内容很有用.例如, ``sphinx.  ext.autodoc`` 使用它来解析docstrings ::"

#: ../../extdev/markupapi.rst:141
msgid ""
"Until Sphinx-1.6, ``sphinx.ext.autodoc.AutodocReporter`` is used for this"
" purpose. For now, it is replaced by ``switch_source_input()``."
msgstr "在Sphinx-1.6之前, ``sphinx.ext.autodoc.AutodocReporter`` 用于此目的.现在, 它被 ``switch_source_input()`` 取代."

#: ../../extdev/markupapi.rst:144
msgid ""
"If you don't need the wrapping node, you can use any concrete node type "
"and return ``node.children`` from the Directive."
msgstr "如果您不需要包装节点, 则可以使用任何具体的节点类型并从指令返回 ``node.children``."

#: ../../extdev/markupapi.rst:150
msgid ""
"`Creating directives <http://docutils.sourceforge.net/docs/howto/rst-"
"directives.html>`_"
msgstr "`创建指令 <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_"

#: ../../extdev/markupapi.rst:151
msgid "HOWTO of the Docutils documentation"
msgstr "关于Docutils文档的HOWTO"

