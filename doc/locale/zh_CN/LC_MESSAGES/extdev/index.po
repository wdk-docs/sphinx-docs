# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2019, Georg Brandl and the Sphinx team
# This file is distributed under the same license as the Sphinx package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx 2.1.0+/1499a97c2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-29 17:17+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../extdev/index.rst:4
msgid "Developing extensions for Sphinx"
msgstr "开发扩展"

#: ../../extdev/index.rst:6
msgid ""
"Since many projects will need special features in their documentation, "
"Sphinx is designed to be extensible on several levels."
msgstr "由于许多项目在其文档中需要特殊功能, 因此Sphinx可以在多个级别上进行扩展."

#: ../../extdev/index.rst:9
msgid ""
"This is what you can do in an extension: First, you can add new "
":term:`builder`\\s to support new output formats or actions on the parsed"
" documents.  Then, it is possible to register custom reStructuredText "
"roles and directives, extending the markup.  And finally, there are so-"
"called \"hook points\" at strategic places throughout the build process, "
"where an extension can register a hook and run specialized code."
msgstr "这是您可以在扩展中执行的操作:首先, 您可以添加新 :term:`builder`\\s 以支持解析文档上的新输出格式或操作.然后, 可以注册自定义的reStructuredText角色和指令, 从而扩展标记.最后, 在整个构建过程中的战略位置都有所谓的 \"hook points\", 扩展可以注册一个钩子并运行专门的代码."

#: ../../extdev/index.rst:16
msgid ""
"An extension is simply a Python module.  When an extension is loaded, "
"Sphinx imports this module and executes its ``setup()`` function, which "
"in turn notifies Sphinx of everything the extension offers -- see the "
"extension tutorial for examples."
msgstr "扩展只是一个Python模块.加载扩展时, Sphinx会导入该模块并执行其 ``setup()`` 函数, 该函数又会向Sphinx通知扩展提供的所有内容 - 请参阅扩展教程中的示例."

#: ../../extdev/index.rst:21
msgid ""
"The configuration file itself can be treated as an extension if it "
"contains a ``setup()`` function.  All other extensions to load must be "
"listed in the :confval:`extensions` configuration value."
msgstr "如果配置文件包含一个 ``setup()`` 函数, 它可以被视为扩展.  加载的所有其他扩展必须列在 :confval:`extensions` 配置值中."

#: ../../extdev/index.rst:26
msgid "Discovery of builders by entry point"
msgstr "通过切入点发现构建器"

#: ../../extdev/index.rst:30
msgid ""
":term:`Builder` extensions can be discovered by means of `entry points`_ "
"so that they do not have to be listed in the :confval:`extensions` "
"configuration value."
msgstr ":term:`Builder` 扩展可以通过 `entry points`_ 来发现, 这样它们就不必列在 :confval:`extensions` 配置值中."

#: ../../extdev/index.rst:34
msgid ""
"Builder extensions should define an entry point in the "
"``sphinx.builders`` group. The name of the entry point needs to match "
"your builder's :attr:`~.Builder.name` attribute, which is the name passed"
" to the :option:`sphinx-build -b` option. The entry point value should "
"equal the dotted name of the extension module. Here is an example of how "
"an entry point for 'mybuilder' can be defined in the extension's "
"``setup.py``::"
msgstr "Builder扩展应该在 ``sphinx.builders`` 组中定义一个入口点. 入口点的名称需要与构建器的匹配 :attr:`〜.Builder.name` 属性, 这是传递给 :option:`sphinx-build -b` 选项的名称. 入口点值应等于扩展模块的虚线名称.这是一个例子, 说明如何在扩展名的 ``setup.py`` 中定义 'mybuilder' 的入口点.::"

#: ../../extdev/index.rst:50
msgid ""
"Note that it is still necessary to register the builder using "
":meth:`~.Sphinx.add_builder` in the extension's :func:`setup` function."
msgstr "请注意, 仍然需要在扩展名 :func:`setup` 函数中使用 :meth:`〜.Sphinx.add_builder` 注册构建器."

#: ../../extdev/index.rst:58
msgid "Important objects"
msgstr "重要的对象"

#: ../../extdev/index.rst:60
msgid ""
"There are several key objects whose API you will use while writing an "
"extension. These are:"
msgstr "在编写扩展时, 您将使用几个关键对象的API.这些是:"

#: ../../extdev/index.rst:69
msgid "**Application**"
msgstr "**应用**"

#: ../../extdev/index.rst:64
msgid ""
"The application object (usually called ``app``) is an instance of "
":class:`.Sphinx`.  It controls most high-level functionality, such as the"
" setup of extensions, event dispatching and producing output (logging)."
msgstr "应用程序对象(通常称为 ``app``)是一个实例 :class:`.Sphinx` .  它控制着大多数高级功能, 例如扩展设置, 事件调度和生成输出(日志记录)."

#: ../../extdev/index.rst:68
msgid ""
"If you have the environment object, the application is available as "
"``env.app``."
msgstr "如果你有环境对象, 那么应用程序就可以作为 ``env.app`` ."

#: ../../extdev/index.rst:82
msgid "**Environment**"
msgstr "**环境**"

#: ../../extdev/index.rst:72
msgid ""
"The build environment object (usually called ``env``) is an instance of "
":class:`.BuildEnvironment`.  It is responsible for parsing the source "
"documents, stores all metadata about the document collection and is "
"serialized to disk after each build."
msgstr "构建环境对象(通常称为 ``env``)是一个实例 :class:`.BuildEnvironment` .  它负责解析源文档, 存储有关文档集合的所有元数据, 并在每次构建后序列化到磁盘."

#: ../../extdev/index.rst:77
msgid ""
"Its API provides methods to do with access to metadata, resolving "
"references, etc.  It can also be used by extensions to cache information "
"that should persist for incremental rebuilds."
msgstr "它的API提供了访问元数据, 解析引用等方法.扩展还可以使用它来缓存应该持续进行增量重建的信息."

#: ../../extdev/index.rst:81
msgid ""
"If you have the application or builder object, the environment is "
"available as ``app.env`` or ``builder.env``."
msgstr "如果您有应用程序或构建器对象, 则该环境可用作 ``app.env`` 或 ``builder.env`` ."

#: ../../extdev/index.rst:91
msgid "**Builder**"
msgstr "**生成器**"

#: ../../extdev/index.rst:85
msgid ""
"The builder object (usually called ``builder``) is an instance of a "
"specific subclass of :class:`.Builder`.  Each builder class knows how to "
"convert the parsed documents into an output format, or otherwise process "
"them (e.g. check external links)."
msgstr "构建器对象(通常称为 ``builder``)是特定子类的实例 :class:`.Builder` .  每个构建器类都知道如何将解析的文档转换为输出格式, 或以其他方式处理它们(例如, 检查外部链接)."

#: ../../extdev/index.rst:90
msgid ""
"If you have the application object, the builder is available as "
"``app.builder``."
msgstr "如果您有应用程序对象, 则构建器可用作 ``app.builder``."

#: ../../extdev/index.rst:98
msgid "**Config**"
msgstr "**配置**"

#: ../../extdev/index.rst:94
msgid ""
"The config object (usually called ``config``) provides the values of "
"configuration values set in :file:`conf.py` as attributes.  It is an "
"instance of :class:`.Config`."
msgstr "config对象(通常称为 ``config``)提供在 :file:`conf.py` 中设置的配置值的值作为属性.  它是一个实例 :class:`.Config` ."

#: ../../extdev/index.rst:98
msgid "The config is available as ``app.config`` or ``env.config``."
msgstr "配置可用作 ``app.config`` 或 ``env.config`` ."

#: ../../extdev/index.rst:100
msgid ""
"To see an example of use of these objects, refer to "
":doc:`../development/tutorials/index`."
msgstr "要查看使用这些对象的示例, 请参阅 :doc:`../development/tutorials/index` ."

#: ../../extdev/index.rst:105
msgid "Build Phases"
msgstr "建立阶段"

#: ../../extdev/index.rst:107
msgid ""
"One thing that is vital in order to understand extension mechanisms is "
"the way in which a Sphinx project is built: this works in several phases."
msgstr "对于理解扩展机制至关重要的一件事是构建Sphinx项目的方式:这在几个阶段中起作用."

#: ../../extdev/index.rst:110
msgid "**Phase 0: Initialization**"
msgstr "**阶段0:初始化**"

#: ../../extdev/index.rst:112
msgid ""
"In this phase, almost nothing of interest to us happens.  The source "
"directory is searched for source files, and extensions are initialized. "
"Should a stored build environment exist, it is loaded, otherwise a new "
"one is created."
msgstr "在这个阶段, 我们几乎没有任何兴趣发生.搜索源目录以查找源文件, 并初始化扩展.如果存在存储的构建环境, 则会加载它, 否则会创建一个新的构建环境."

#: ../../extdev/index.rst:117
msgid "**Phase 1: Reading**"
msgstr "**阶段1: 阅读**"

#: ../../extdev/index.rst:119
msgid ""
"In Phase 1, all source files (and on subsequent builds, those that are "
"new or changed) are read and parsed.  This is the phase where directives "
"and roles are encountered by docutils, and the corresponding code is "
"executed.  The output of this phase is a *doctree* for each source file; "
"that is a tree of docutils nodes.  For document elements that aren't "
"fully known until all existing files are read, temporary nodes are "
"created."
msgstr "在阶段1中, 将读取和解析所有源文件(以及后续构建, 新的或更改的源文件). 这是docutils遇到指令和角色的阶段, 并执行相应的代码. 此阶段的输出是每个源文件的 *doctree* ;这是一个docutils节点的树. 对于在读取所有现有文件之前未完全知晓的文档元素, 将创建临时节点."

#: ../../extdev/index.rst:126
msgid ""
"There are nodes provided by docutils, which are documented `in the "
"docutils documentation "
"<http://docutils.sourceforge.net/docs/ref/doctree.html>`__. Additional "
"nodes are provided by Sphinx and :ref:`documented here <nodes>`."
msgstr "docutils提供了一些节点, 这些节点在 `docutils文档中 <http://docutils.sourceforge.net/docs/ref/doctree.html>`__ 记录. 其他节点由Sphinx提供, 并且 :ref:`此处记录 <nodes>`."

#: ../../extdev/index.rst:130
msgid ""
"During reading, the build environment is updated with all meta- and cross"
" reference data of the read documents, such as labels, the names of "
"headings, described Python objects and index entries.  This will later be"
" used to replace the temporary nodes."
msgstr "在阅读期间, 使用所读取文档的所有元数据和交叉引用数据更新构建环境, 例如标签, 标题名称, 描述的Python对象和索引条目.  这将在以后用于替换临时节点."

#: ../../extdev/index.rst:135
msgid ""
"The parsed doctrees are stored on the disk, because it is not possible to"
" hold all of them in memory."
msgstr "解析后的doctree存储在磁盘上, 因为无法将所有这些都保存在内存中."

#: ../../extdev/index.rst:138
msgid "**Phase 2: Consistency checks**"
msgstr "**阶段2: 一致性检查**"

#: ../../extdev/index.rst:140
msgid "Some checking is done to ensure no surprises in the built documents."
msgstr "进行一些检查以确保构建文档中没有意外."

#: ../../extdev/index.rst:142
msgid "**Phase 3: Resolving**"
msgstr "**阶段3: 解决**"

#: ../../extdev/index.rst:144
msgid ""
"Now that the metadata and cross-reference data of all existing documents "
"is known, all temporary nodes are replaced by nodes that can be converted"
" into output using components called transforms.  For example, links are "
"created for object references that exist, and simple literal nodes are "
"created for those that don't."
msgstr "现在已知所有现有文档的元数据和交叉引用数据, 所有临时节点都被可以使用称为变换的组件转换为输出的节点替换. 例如, 为存在的对象引用创建链接, 并为不存在的对象引用创建简单的文字节点."

#: ../../extdev/index.rst:150
msgid "**Phase 4: Writing**"
msgstr "**阶段4: 编辑**"

#: ../../extdev/index.rst:152
msgid ""
"This phase converts the resolved doctrees to the desired output format, "
"such as HTML or LaTeX.  This happens via a so-called docutils writer that"
" visits the individual nodes of each doctree and produces some output in "
"the process."
msgstr "此阶段将已解析的doctree转换为所需的输出格式, 例如HTML或LaTeX. 这通过所谓的docutils编写器发生, 该编写器访问每个doctree的各个节点并在该过程中产生一些输出."

#: ../../extdev/index.rst:158
msgid ""
"Some builders deviate from this general build plan, for example, the "
"builder that checks external links does not need anything more than the "
"parsed doctrees and therefore does not have phases 2--4."
msgstr "某些构建器偏离此常规构建计划, 例如, 检查外部链接的构建器不需要比解析的doctree更多的内容, 因此没有阶段2--4."

#: ../../extdev/index.rst:162
msgid ""
"To see an example of application, refer to "
":doc:`../development/tutorials/todo`."
msgstr "要查看应用程序示例, 请参阅 :doc:`../development/tutorials/todo`."

#: ../../extdev/index.rst:167
msgid "Extension metadata"
msgstr "扩展元数据"

#: ../../extdev/index.rst:171
msgid ""
"The ``setup()`` function can return a dictionary.  This is treated by "
"Sphinx as metadata of the extension.  Metadata keys currently recognized "
"are:"
msgstr "``setup()`` 函数可以返回一个字典. 这被Sphinx视为扩展的元数据. 当前识别的元数据键是:"

#: ../../extdev/index.rst:174
msgid ""
"``'version'``: a string that identifies the extension version.  It is "
"used for extension version requirement checking (see "
":confval:`needs_extensions`) and informational purposes.  If not given, "
"``\"unknown version\"`` is substituted."
msgstr "``'version'``: 标识扩展版本的字符串. 它用于扩展版本要求检查(请参阅 :confval:`needs_extensions`)和信息用途. 如果没有给出, ``\"unknown version\"`` 被替换."

#: ../../extdev/index.rst:177
msgid ""
"``'env_version'``: an integer that identifies the version of env data "
"structure if the extension stores any data to environment.  It is used to"
" detect the data structure has been changed from last build.  The "
"extensions have to increment the version when data structure has changed."
"  If not given, Sphinx considers the extension does not stores any data "
"to environment."
msgstr "``'env_version'``: 如果扩展将任何数据存储到环境, 则标识env数据结构版本的整数. 它用于检测从上次构建更改的数据结构. 扩展必须在数据结构发生变化时增加版本. 如果没有给出, Sphinx认为扩展不会将任何数据存储到环境中."

#: ../../extdev/index.rst:182
msgid ""
"``'parallel_read_safe'``: a boolean that specifies if parallel reading of"
" source files can be used when the extension is loaded.  It defaults to "
"``False``, i.e. you have to explicitly specify your extension to be "
"parallel-read-safe after checking that it is."
msgstr "``'parallel_read_safe'``: 一个布尔值, 指定在加载扩展时是否可以使用源文件的并行读取. 它默认为 ``False`` , 即你必须在检查它之后明确指定你的扩展是并行读取安全的."

#: ../../extdev/index.rst:186
msgid ""
"``'parallel_write_safe'``: a boolean that specifies if parallel writing "
"of output files can be used when the extension is loaded.  Since "
"extensions usually don't negatively influence the process, this defaults "
"to ``True``."
msgstr "``'parallel_write_safe'``: 一个布尔值, 指定在加载扩展时是否可以使用输出文件的并行写入. 由于扩展通常不会对进程产生负面影响, 因此默认为 ``True``."

#: ../../extdev/index.rst:192
msgid "APIs used for writing extensions"
msgstr "用于编写扩展的API"

